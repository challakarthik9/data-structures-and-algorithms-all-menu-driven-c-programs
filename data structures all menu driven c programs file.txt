C Program for Depth First Binary Tree Search using Recursion

#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
};
 
void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            DFS(head);
            break;
        case 3: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: 
            printf("Not a valid input, try again\n");
        }
    } while (choice != 3);
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        if (num >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
void DFS(struct node *head)
{
    if (head)
    {
        if (head->left)
        {
            DFS(head->left);
        }
        if (head->right)
        {
            DFS(head->right);
        }
        printf("%d  ", head->a);
    }
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}



* C Program to Traverse the Tree Recursively
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
};
 
void generate(struct node **, int);
void infix(struct node *);
void postfix(struct node *);
void prefix(struct node *);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Traverse via infix\n3.Traverse via prefix\n4. Traverse via postfix\n5. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            infix(head);
            break;
        case 3: 
            prefix(head);
            break;
        case 4: 
            postfix(head);
            break;
        case 5: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: printf("Not a valid input, try again\n");
        }
    } while (choice != 5);
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        if (num >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
void infix(struct node *head)
{
    if (head)
    {
        infix(head->left);
        printf("%d   ", head->a);
        infix(head->right);
    }
}
 
void prefix(struct node *head)
{
    if (head)
    {
        printf("%d   ", head->a);
        prefix(head->left);
        prefix(head->right);
    }
}
 
void postfix(struct node *head)
{
    if (head)
    {
        postfix(head->left);
        postfix(head->right);
        printf("%d   ", head->a);
    }
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}


* C Program to Search an Element in a Tree Recursively
 */
 
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
};
 
void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            printf("Enter key to search: ");
            scanf("%d", &key);
            flag = search(head, key);
            if (flag)
            {
                printf("Key found in tree\n");
            }
            else
            {
                printf("Key not found\n");
            }
            break;
        case 3: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: 
            printf("Not a valid input, try again\n");
        }
    } while (choice != 3);
 
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        if (num >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
int search(struct node *head, int key)
{
    while (head != NULL)
    {
        if (key > head->a)
        {
            return search(head->right, key);
        }
        else if (key < head->a)
        {
            return search(head->left, key);
        }
        else
        {
            return 1;
        }
    }
 
    return 0;
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}
 * C Program to Traverse the Tree Non-Recursively
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
};
 
void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            printf("Enter key to search: ");
            scanf("%d", &key);
            flag = search(head, key);
            if (flag)
            {
                printf("Key found in tree\n");
            }
            else
            {
                printf("Key not found\n");
            }
            break;
        case 3: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: printf("Not a valid input, try again\n");
        }
    } while (choice != 3);
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        if (num >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
int search(struct node *head, int key)
{
    while (head != NULL)
    {
        if (key > head->a)
        {
            head = head->right;
        }
        else if (key < head->a)
        {
            head = head->left;
        }
        else
        {
            return 1;
        }
    }
	return 0;
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}


* C Program to Traverse the Tree Non-Recursively
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
};
 
void generate(struct node **, int);
int search(struct node *, int);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Search\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            printf("Enter key to search: ");
            scanf("%d", &key);
            flag = search(head, key);
            if (flag)
            {
                printf("Key found in tree\n");
            }
            else
            {
                printf("Key not found\n");
            }
            break;
        case 3: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: printf("Not a valid input, try again\n");
        }
    } while (choice != 3);
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        if (num >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
int search(struct node *head, int key)
{
    while (head != NULL)
    {
        if (key > head->a)
        {
            head = head->right;
        }
        else if (key < head->a)
        {
            head = head->left;
        }
        else
        {
            return 1;
        }
    }
	return 0;
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}



* C Program for Depth First Binary Tree Search without using 
 * Recursion
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int a;
    struct node *left;
    struct node *right;
    int visited;
};
 
void generate(struct node **, int);
void DFS(struct node *);
void delete(struct node **);
 
int main()
{
    struct node *head = NULL;
    int choice = 0, num, flag = 0, key;
 
    do
    {
        printf("\nEnter your choice:\n1. Insert\n2. Perform DFS Traversal\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1: 
            printf("Enter element to insert: ");
            scanf("%d", &num);
            generate(&head, num);
            break;
        case 2: 
            DFS(head);
            break;
        case 3: 
            delete(&head);
            printf("Memory Cleared\nPROGRAM TERMINATED\n");
            break;
        default: 
            printf("Not a valid input, try again\n");
        }
    } while (choice != 3);
 
    return 0;
}
 
void generate(struct node **head, int num)
{
    struct node *temp = *head, *prev = *head;
 
    if (*head == NULL)
    {
        *head = (struct node *)malloc(sizeof(struct node));
        (*head)->a = num;
        (*head)->visited = 0;
        (*head)->left = (*head)->right = NULL;
    }
    else
    {
        while (temp != NULL)
        {
            if (num > temp->a)
            {
                prev = temp;
                temp = temp->right;
            }
            else
            {
                prev = temp;
                temp = temp->left;
            }
        }
        temp = (struct node *)malloc(sizeof(struct node));
        temp->a = num;
        temp->visited = 0;
        if (temp->a >= prev->a)
        {
            prev->right = temp;
        }
        else
        {
            prev->left = temp;
        }
    }
}
 
void DFS(struct node *head)
{
    struct node *temp = head, *prev;
 
    printf("On DFS traversal we get:\n");
    while (temp && !temp->visited)
    {
        if (temp->left && !temp->left->visited)
        {
            temp = temp->left;
        }
        else if (temp->right && !temp->right->visited)
        {
            temp = temp->right;
        }
        else
        {
            printf("%d  ", temp->a);
            temp->visited = 1;
            temp = head;
        }
    }
}
 
void delete(struct node **head)
{
    if (*head != NULL)
    {
        if ((*head)->left)
        {
            delete(&(*head)->left);
        }
        if ((*head)->right)
        {
            delete(&(*head)->right);
        }
        free(*head);
    }
}

* C Program to Find Nth Node in the Inorder Traversal of a Tree
 */
 
typedef struct node
{
    int value;
    struct node *left;
    struct node *right;
}newnode;
 
newnode *root;
static ctr;
 
void nthnode(newnode *root, int n, newnode **nthnode);
int main()
{
    newnode *temp;
    root=0;
 
    // Construct the tree
    add(19);
    add(20);
    add(11);
    inorder(root);
    // Get the pointer to the nth Inorder node
    nthinorder(root, 6, &temp);
    printf("\n[%d]\n", temp->value);
    return(0);
}
 
// Get the pointer to the nth inorder node in "nthnode"
void nthinorder(newnode *root, int n, newnode **nthnode)
{
    static whichnode;
    static found;
 
    if (!found)
    {
        if (root)
        {
            nthinorder(root->left, n , nthnode);
            if (++whichnode == n)
            {
                printf("\n Found %dth node\n", n);
                found = 1;
                *nthnode = root;
            }
            nthinorder(root->right, n , nthnode);
        }
    }
}
 
inorder(newnode *root)
{
}
// Add value to a Binary Search Tree
add(int value)
{
    newnode *temp, *prev, *cur;
 
    temp = malloc(sizeof(newnode));
    temp->value = value;
    temp->left  = 0;
    temp->right = 0;
    if (root == 0)
    {
        root = temp;
    }
    else
    {
        prev = 0;
        cur = root;
        while(cur)
        {
            prev = cur;
            cur =(value < cur->value)? cur->left : cur->right;
        }
        if (value > prev->value)
            prev->right = temp;
        else
            prev->left  = temp;
    }
}



 C Program to Find the Largest value in a Tree using 
 * Inorder Traversal
 *                40
 *                /\
 *              20 60
 *              /\  \
 *            10 30 80
 *                   \
 *                   90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{ 
    int value; 
    struct btnode *left, *right; 
}; 
typedef struct btnode node;
 
/* function prototypes */
 
void insert(node *, node *);
void inorder(node *);
void largest(node *);
 
void main() 
{ 
    node *root = NULL, *new = NULL ; 
    int num = 1;
 
    printf("Enter the elements of the tree(enter 0 to exit)\n"); 
    while (1) 
    {     
        scanf("%d",  &num); 
        if (num == 0) 
            break; 
        new  =  malloc(sizeof(node)); 
        new->left  =  new->right  =  NULL; 
        new->value  =  num; 
        if (root  ==  NULL) 
            root = new; 
        else 
        { 
            insert(new, root); 
        } 
    }
    printf("elements in a tree in inorder are\n"); 
    inorder(root);
    largest(root);
}
 
/* displaying nodes of a tree using inorder */
 
void inorder(node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        printf("%d -> ", root->value);
        inorder(root->right);
    }
}
 
/* inserting nodes into the tree */
 
void insert(node * new , node *root) 
{ 
    if (new->value > root->value) 
    {     
        if (root->right  ==  NULL) 
            root->right  =  new; 
        else 
            insert (new, root->right); 
    } 
    if (new->value < root->value) 
    {     
        if (root->left  == NULL) 
            root->left = new; 
        else 
            insert(new, root->left); 
    }     
}
 
/* finding largest node in a tree */
void largest(node *root)
{
    if (root->right  == NULL) 
    {
        printf("largest element is %d", root->value);
    }
    while (root != NULL && root->right != NULL)
    {
        root = root->right;
    }
    printf("\nlargest value is %d\n", root->value);
}




* C Program to Implement Depth First Search Traversal using Post Order
       50
      /  \
    20   30
   /  \    
  70  80
 /  \    \
10  40   60    
(50, 20, 30, 70, 80, 10, 40, 60)
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
typedef struct btnode bt;
bt *root;
bt *new, *list;
bt *create_node();
void display(bt *);
void construct_tree();
void dfs(bt *);
 
void main()
{
    construct_tree();
    display(root);
    printf("\n");
    printf("Depth first traversal\n ");
    dfs(root);
}
 
/* Creates an empty node */
bt * create_node()
{
    new=(bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
}
 
/* Constructs a tree */
void construct_tree()
{
    root = create_node();
    root->value = 50;
    root->l = create_node();
    root->l->value = 20;
    root->r = create_node();
    root->r->value = 30;
    root->l->l = create_node();
    root->l->l->value = 70;
    root->l->r = create_node();
    root->l->r->value = 80;
    root->l->r->r = create_node();
    root->l->r->r->value = 60;
    root->l->l->l = create_node();
    root->l->l->l->value = 10;
    root->l->l->r = create_node();
    root->l->l->r->value = 40;      
}
 
/* Display the elements in a tree using inorder */
void display(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    display(list->l);
    printf("->%d", list->value);
    display(list->r);
}
 
/* Dfs traversal using post order */
void dfs(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    dfs(list->l);
    dfs(list->r);
    printf("->%d ", list->value);
}




* C Program to Find the Largest value in a Tree using 
 * Inorder Traversal
 *                40
 *                /\
 *              20 60
 *              /\  \
 *            10 30 80
 *                   \
 *                   90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{ 
    int value; 
    struct btnode *left, *right; 
}; 
typedef struct btnode node;
 
/* function prototypes */
 
void insert(node *, node *);
void inorder(node *);
void largest(node *);
 
void main() 
{ 
    node *root = NULL, *new = NULL ; 
    int num = 1;
 
    printf("Enter the elements of the tree(enter 0 to exit)\n"); 
    while (1) 
    {     
        scanf("%d",  &num); 
        if (num == 0) 
            break; 
        new  =  malloc(sizeof(node)); 
        new->left  =  new->right  =  NULL; 
        new->value  =  num; 
        if (root  ==  NULL) 
            root = new; 
        else 
        { 
            insert(new, root); 
        } 
    }
    printf("elements in a tree in inorder are\n"); 
    inorder(root);
    largest(root);
}
 
/* displaying nodes of a tree using inorder */
 
void inorder(node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        printf("%d -> ", root->value);
        inorder(root->right);
    }
}
 
/* inserting nodes into the tree */
 
void insert(node * new , node *root) 
{ 
    if (new->value > root->value) 
    {     
        if (root->right  ==  NULL) 
            root->right  =  new; 
        else 
            insert (new, root->right); 
    } 
    if (new->value < root->value) 
    {     
        if (root->left  == NULL) 
            root->left = new; 
        else 
            insert(new, root->left); 
    }     
}
 
/* finding largest node in a tree */
void largest(node *root)
{
    if (root->right  == NULL) 
    {
        printf("largest element is %d", root->value);
    }
    while (root != NULL && root->right != NULL)
    {
        root = root->right;
    }
    printf("\nlargest value is %d\n", root->value);
}



* C Program to Create a Mirror Copy of a Tree and Display using 
 * BFS Traversal
 *                    40
 *                    /\
 *                   20 60
 *                   /\  \
 *                  10 30  80
 *                          \
 *                           90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{ 
    int value; 
    struct btnode *left, *right; 
}; 
typedef struct btnode node;
 
/* function prototypes */
void insert(node *, node *);
void mirror(node *);
 
/* global variables */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];
 
void main() 
{ 
    node *new = NULL ; 
    int num = 1; 
    printf("Enter the elements of the tree(enter 0 to exit)\n"); 
    while (1) 
    {     
        scanf("%d",  &num); 
        if (num == 0) 
            break; 
        new = malloc(sizeof(node)); 
        new->left = new->right = NULL; 
        new->value = num; 
        if (root == NULL) 
            root = new; 
        else 
        { 
            insert(new, root); 
        } 
    }
    printf("mirror image of tree is\n"); 
    queue[++rear] = root->value;
    mirror(root);
    for (i = 0;i <= rear;i++)
        printf("%d -> ", queue[i]);
    printf("%d\n", root->right->right->right->value);
}
 
/* inserting nodes into the tree */
void insert(node * new , node *root) 
{ 
    if (new->value > root->value) 
    {     
        if (root->right == NULL) 
            root->right = new; 
        else 
            insert (new, root->right); 
    } 
    if (new->value < root->value) 
    {     
        if (root->left == NULL) 
            root->left = new; 
        else 
            insert (new, root->left); 
    }     
}
 
/* mirror image of nodes */
void mirror(node *root)
{
    val = root->value;
    if ((front <= rear) && (root->value == queue[front])) 
    {
        if (root->right != NULL || root->right == NULL)
            queue[++rear] = root->right->value;
        if (root->left != NULL)
            queue[++rear] = root->left->value;
        front++;
    }
    if (root->right != NULL)
    {
        mirror(root->right);
    }
    if (root->left != NULL)
    {
        mirror(root->left);
    }
}





* C  Program to Build Binary Tree if Inorder or Postorder Traversal as Input
 *
 *                     40
 *                    /  \
 *                   20   60
 *                  /  \   \
 *                 10  30   80
 *                           \
 *                           90    
 *             (Given Binary Search Tree)    
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root = NULL, *temp = NULL;
 
typedef struct btnode N;
void insert();
N* bt(int arr[],int,int);
N* new(int);
void inorder(N *t);
void create();
void search(N *t);
void preorder(N *t);
void postorder(N *t);
 
void main()
{
    int ch, i, n;
    int arr[] = {10, 20, 30, 40, 60, 80, 90};
    n = sizeof(arr) / sizeof(arr[0]);
 
    printf("\n1- Inorder\n");
    printf("2 - postorder\n");
    printf("\nEnter choice : ");
    scanf("%d", &ch);
    switch (ch)
    {
    case 1:
        root = bt(arr, 0, n-1); 
        printf("Given inorder traversal as input\n");
        for (i = 0;i< = 6;i++)
            printf("%d->", arr[i]);
        printf("\npreorder traversal of tree\n");
        preorder(root);
        printf("\ninorder traversal of tree\n");
        inorder(root);
        printf("\npostorder traversal of tree\n");
        postorder(root);
        break;
    case 2:
        insert();
        printf("\npreorder traversal of tree\n");
        preorder(root);
        printf("\nInorder traversal of tree\n");
        inorder(root);
        printf("\npostorder traversal of tree\n");
        postorder(root);
        break;
        default:printf("enter correct choice");
    }
}
 
/* To create a new node */
N* new(int val)
{
    N* node = (N*)malloc(sizeof(N));
 
    node->value = val;
    node->l = NULL;
    node->r  =  NULL;
    return node;
}
 
/* To create a balanced binary search tree */
N* bt(int arr[], int first, int last)
{
    int mid;
 
    N* root = (N*)malloc(sizeof(N));
    if (first > last)
        return NULL;
    mid = (first + last) / 2;
    root = new(arr[mid]);
    root->l = bt(arr, first, mid - 1);
    root->r = bt(arr, mid + 1, last);
    return root;
}
 
/* Insert a node in the tree */
void insert()
{
    int arr1[] = {10, 30, 20, 90, 80, 60, 40}, i;
 
    printf("Given post order traversal array\n");
    for (i = 0;i <= 6;i++)
    {
        printf("%d->", arr1[i]);
     }
    for (i = 6;i >= 0;i--) 
    {
        create(arr1[i]);
        if (root =  = NULL)
            root = temp;
        else
            search(root);
    }
}
 
/*Create a node */
void create(int data)
{
    temp = (N *)malloc(1*sizeof(N));
 
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* Search for the appropriate position to insert the new node */
void search(N *t)
{
    if ((temp->value>t->value)&&(t->r != NULL))
        search(t->r);
    else if ((temp->value>t->value)&&(t->r  == NULL))
        t->r = temp;
    else if ((temp->value<t->value)&&(t->l != NULL))
        search(t->l);
    else if ((temp->value<t->value)&&(t->l == NULL))
        t->l = temp;
}
 
/* to display inorder of tree */
void inorder(N *t)
{
    if (t->l != NULL)
        inorder(t->l);
    printf("%d->", t->value);
    if (t->r != NULL)
        inorder(t->r);
}
 
/* to display preorder traversal of tree */
void preorder(N *t) 
{
    printf("%d->", t->value);
    if (t->l != NULL)
        inorder(t->l);
    if (t->r != NULL)
        inorder(t->r);
}
 
/* to display postorder traversal of tree */
void postorder(N *t) 
{
    if (t->l != NULL)
        inorder(t->l);
    if (t->r != NULL)
        inorder(t->r);
    printf("%d->", t->value);
}


////////////C Examples on Heap and Binary Tree Implementation//////////


* C Program to Implement Binary Tree using Linked List
 */
#include <stdio.h>
#include <malloc.h>
 
struct node {
    struct node * left;
    char data;
    struct node * right;
};
 
struct node *constructTree( int );
void inorder(struct node *);
 
char array[ ] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', '\0', '\0', 'H' };
int leftcount[ ] = {  1,   3,   5,   -1,   9,  -1,  -1,   -1,   -1,  -1 };
int rightcount[ ] = {  2,   4,   6,   -1,  -1,  -1,  -1,   -1,   -1,  -1 };
 
void main() {
    struct node *root;
    root = constructTree( 0 );
    printf("In-order Traversal: \n");
    inorder(root);
}
 
struct node * constructTree( int index ) {
    struct node *temp = NULL;
    if (index != -1) {
        temp = (struct node *)malloc( sizeof ( struct node ) );
        temp->left = constructTree( leftcount[index] );
        temp->data = array[index];
        temp->right = constructTree( rightcount[index] );
    }
    return temp;
}
 
void inorder( struct node *root ) {
    if (root != NULL) {
        inorder(root->left);
        printf("%c\t", root->data);
        inorder(root->right);
    }
}


///////* C Program to Implement a Heap & provide Insertion & Deletion Operation **********////////////
#include <stdio.h>
 
int array[100], n;
main()
{
    int choice, num;
    n = 0;/*Represents number of nodes in the heap*/
    while(1)
    {
        printf("1.Insert the element \n");
        printf("2.Delete the element \n");
        printf("3.Display all elements \n");
        printf("4.Quit \n");
        printf("Enter your choice : ");
        scanf("%d", &choice);
        switch(choice)
        {
        case 1:
            printf("Enter the element to be inserted to the list : ");
            scanf("%d", &num);
            insert(num, n);
            n = n + 1;
            break;
        case 2:
            printf("Enter the elements to be deleted from the list: ");
            scanf("%d", &num);
            delete(num);
            break;
        case 3:
            display();
            break;
        case 4:
            exit(0);
        default:
            printf("Invalid choice \n");
    }/*End  of switch */
}/*End of while */
}/*End of main()*/
 
display()
{
    int i;
    if (n == 0)
    {
        printf("Heap is empty \n");
        return;
    }
    for (i = 0; i < n; i++)
        printf("%d ", array[i]);
    printf("\n");
}/*End of display()*/
 
insert(int num, int location)
{
    int parentnode;
    while (location > 0)
    {
        parentnode =(location - 1)/2;
        if (num <= array[parentnode])
        {
            array[location] = num;
            return;
        }
        array[location] = array[parentnode];
        location = parentnode;
    }/*End of while*/
    array[0] = num; /*assign number to the root node */
}/*End of insert()*/
 
delete(int num)
{
    int left, right, i, temp, parentnode;
 
    for (i = 0; i < num; i++) {
        if (num == array[i])
            break;
    }
    if (num != array[i])
    {
        printf("%d not found in heap list\n", num);
        return;
    }
    array[i] = array[n - 1];
    n = n - 1;
    parentnode =(i - 1) / 2; /*find parentnode of node i */
    if (array[i] > array[parentnode])
    {
        insert(array[i], i);
        return;
    }
    left = 2 * i + 1; /*left child of i*/
    right = 2 * i + 2; /* right child of i*/
    while (right < n)
    {
        if (array[i] >= array[left] && array[i] >= array[right])
            return;
        if (array[right] <= array[left])
        {
            temp = array[i];
            array[i] = array[left];
            array[left] = temp;
            i = left;
        }
        else
        {
            temp = array[i];
            array[i] = array[right];
            array[right] = temp;
            i = right;
        }
        left = 2 * i + 1;
        right = 2 * i + 2;
    }/*End of while*/
    if (left == n - 1 && array[i])    {
        temp = array[i];
        array[i] = array[left];
        array[left] = temp;
    }
}




/*
 * C Program to Construct a B Tree
 */
 
/***************************
 * binarytree.h
 ***************************/
 
typedef char DATA;
 
struct node
{
	DATA d;
	struct node *left;
	struct node *right;
};
 
typedef struct node NODE;
typedef NODE *BTREE;
 
BTREE newnode(void);
BTREE init_node(DATA d, BTREE p1, BTREE p2);
BTREE create_tree(DATA a[], int i, int size);
void preorder (BTREE root);
void inorder (BTREE root);
void postorder (BTREE root);
 
/**********************
 * binarytree.c:
 ***********************/
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "binarytree.h"
 
BTREE new_node()
{
    return ((BTREE)malloc(sizeof(NODE)));
}
 
BTREE init_node(DATA d1, BTREE p1, BTREE p2)
{
    BTREE t;
 
    t = new_node();
    t->d = d1;
    t->left = p1;
    t->right = p2;
    return t;
}
 
/* create a linked binary tree from an array */
BTREE create_tree(DATA a[], int i, int size)
{
    if (i >= size)
        return NULL;
    else
        return(init_node(a[i],
    create_tree(a, 2*i+1, size),
    create_tree(a, 2*i+2, size)));
}
 
/* preorder traversal */
void preorder (BTREE root)
{
    if (root != NULL) {
        printf("%c ", root->d);
        preorder(root -> left);
        preorder(root -> right);
    }
}
 
/* Inorder traversal */
void inorder (BTREE root)
{
    if (root != NULL) {
        inorder(root -> left);
        printf("%c ", root->d);
        inorder(root -> right);
    }
}
 
/* postorder binary tree traversal */
 
void postorder (BTREE root)
{
    if (root != NULL) {
        postorder(root -> left);
        postorder(root -> right);
        printf("%c ", root->d);
    }
}
 
/***************************
 * pgm.c
 ***************************/
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
 
#include "binarytree.c"
#define ARRAY_SIZE 10
int main(void)
{
    char a[ARRAY_SIZE] = {'g','d','i','b','f','h','j','a','c','e'};
    BTREE root;
 
    root = create_tree(a, 0, ARRAY_SIZE) ;
    assert(root != NULL);
    printf("PREORDER\n");
    preorder(root);
    printf("\n");
    printf("INORDER\n");
    inorder(root);
    printf("\n");
 
    printf("POSTORDER\n");
    postorder(root);
    printf("\n");
}



/* 
 * C Program to Construct a Binary Search Tree and perform deletion, inorder traversal on it
 */ 
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root = NULL, *temp = NULL, *t2, *t1;
 
void delete1();
void insert();
void delete();
void inorder(struct btnode *t);
void create();
void search(struct btnode *t);
void preorder(struct btnode *t);
void postorder(struct btnode *t);
void search1(struct btnode *t,int data);
int smallest(struct btnode *t);
int largest(struct btnode *t);
 
int flag = 1;
 
void main()
{
    int ch;
 
    printf("\nOPERATIONS ---");
    printf("\n1 - Insert an element into tree\n");
    printf("2 - Delete an element from the tree\n");
    printf("3 - Inorder Traversal\n");
    printf("4 - Preorder Traversal\n");
    printf("5 - Postorder Traversal\n");
    printf("6 - Exit\n");
    while(1)
    {
        printf("\nEnter your choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:    
            insert();
            break;
        case 2:    
            delete();
            break;
        case 3:    
            inorder(root);
            break;
        case 4:    
            preorder(root);
            break;
        case 5:    
            postorder(root);
            break;
        case 6:    
            exit(0);
        default :     
            printf("Wrong choice, Please enter correct choice  ");
            break;    
        }
    }
}
 
/* To insert a node in the tree */
void insert()
{
    create();
    if (root == NULL) 
        root = temp;
    else    
        search(root);    
}
 
/* To create a node */
void create()
{
    int data;
 
    printf("Enter data of node to be inserted : ");
    scanf("%d", &data);
    temp = (struct btnode *)malloc(1*sizeof(struct btnode));
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* Function to search the appropriate position to insert the new node */
void search(struct btnode *t)
{
    if ((temp->value > t->value) && (t->r != NULL))      /* value more than root node value insert at right */
        search(t->r);
    else if ((temp->value > t->value) && (t->r == NULL))
        t->r = temp;
    else if ((temp->value < t->value) && (t->l != NULL))    /* value less than root node value insert at left */
        search(t->l);
    else if ((temp->value < t->value) && (t->l == NULL))
        t->l = temp;
}
 
/* recursive function to perform inorder traversal of tree */
void inorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display");
        return;
    }
    if (t->l != NULL)    
        inorder(t->l);
    printf("%d -> ", t->value);
    if (t->r != NULL)    
        inorder(t->r);
}
 
/* To check for the deleted node */
void delete()
{
    int data;
 
    if (root == NULL)
    {
        printf("No elements in a tree to delete");
        return;
    }
    printf("Enter the data to be deleted : ");
    scanf("%d", &data);
    t1 = root;
    t2 = root;
    search1(root, data);
}
 
/* To find the preorder traversal */
void preorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display");
        return;
    }
    printf("%d -> ", t->value);
    if (t->l != NULL)    
        preorder(t->l);
    if (t->r != NULL)    
        preorder(t->r);
}
 
/* To find the postorder traversal */
void postorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display ");
        return;
    }
    if (t->l != NULL) 
        postorder(t->l);
    if (t->r != NULL) 
        postorder(t->r);
    printf("%d -> ", t->value);
}
 
/* Search for the appropriate position to insert the new node */
void search1(struct btnode *t, int data)
{
    if ((data>t->value))
    {
        t1 = t;
        search1(t->r, data);
    }
    else if ((data < t->value))
    {
        t1 = t;
        search1(t->l, data);
    }
    else if ((data==t->value))
    {
        delete1(t);
    }
}
 
/* To delete a node */
void delete1(struct btnode *t)
{
    int k;
 
    /* To delete leaf node */
    if ((t->l == NULL) && (t->r == NULL))
    {
        if (t1->l == t)
        {
            t1->l = NULL;
        }
        else
        {
            t1->r = NULL;
        }
        t = NULL;
        free(t);
        return;
    }
 
    /* To delete node having one left hand child */
    else if ((t->r == NULL))
    {
        if (t1 == t)
        {
            root = t->l;
            t1 = root;
        }
        else if (t1->l == t)
        {
            t1->l = t->l;
 
        }
        else
        {
            t1->r = t->l;
        }
        t = NULL;
        free(t);
        return;
    }
 
    /* To delete node having right hand child */
    else if (t->l == NULL)
    {
        if (t1 == t)
        {
            root = t->r;
            t1 = root;
        }
        else if (t1->r == t)
            t1->r = t->r;
        else
            t1->l = t->r;
        t == NULL;
        free(t);
        return;
    }
 
    /* To delete node having two child */
    else if ((t->l != NULL) && (t->r != NULL))  
    {
        t2 = root;
        if (t->r != NULL)
        {
            k = smallest(t->r);
            flag = 1;
        }
        else
        {
            k =largest(t->l);
            flag = 2;
        }
        search1(root, k);
        t->value = k;
    }
 
}
 
/* To find the smallest element in the right sub tree */
int smallest(struct btnode *t)
{
    t2 = t;
    if (t->l != NULL)
    {
        t2 = t;
        return(smallest(t->l));
    }
    else    
        return (t->value);
}
 
/* To find the largest element in the left sub tree */
int largest(struct btnode *t)
{
    if (t->r != NULL)
    {
        t2 = t;
        return(largest(t->r));
    }
    else    
        return(t->value);
}

* C Program To Find the Smallest and Largest Elements 
 * in the Binary Search Tree
 *                    40
 *                   /  \
 *                  20   60
 *                 /  \   \
 *                10  30   80
 *                         \
 *                         90    
 *            (Given Binary Search Tree)    
 *
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root  =  NULL;
 
typedef struct btnode N;
N* new(int);
void create();
void preorder(N *t);
void min_max(N *t);
 
void main()
{
    int choice;
 
    create();
    while (1)
    {
        printf("Enter the choice\n");
        printf("1-Display : 2-Min & Max element : 3-Exit\n");
        scanf("%d", &choice);
        switch (choice)
        {
 
        case 1:
            printf("preorder preorder of tree elements\n");
            preorder(root);
            printf("\n");
            break;
        case 2:
            min_max(root);
            break;
        case 3:
            exit(0);
        default:
            printf("Enter the right choice\n");
        }
    }
}
 
/* creating temporary node */
N* new(int data)
{
    N* temp = (N*)malloc(sizeof(N));
    temp->value = data;
    temp->l = NULL;
    temp->r = NULL;
 
    return(temp);
}
 
/* Creating the binary search tree */
void create()
{
    root = new(40);
    root->l = new(20);
    root->r = new(60);
    root->l->l = new(10);
    root->l->r = new(30);
    root->r->r = new(80);
    root->r->r->r = new(90);
}
 
/* To display preorder traversal of the tree */
void preorder(N *temp)
{
        printf("%d->", temp->value);
        if (temp->l != NULL)
        preorder(temp->l);
        if (temp->r != NULL)
        preorder(temp->r);
}
 
/* TO find the minimum and maximum values in the given tree */
void min_max(N *temp)
{
    while (temp->l != NULL)
        temp = temp->l;
    printf("Minimum value  = %d\n", temp->value);
    temp = root;
    while (temp->r != NULL)
        temp = temp->r;
    printf("Maximum value  = %d\n", temp->value);
}



//////////////* C Program to Construct a Balenced Binary Tree using Sorted Array
 *                   40
 *                   /  \
 *                  20   60
 *                 /  \   \
 *                10  30   80
 *                          \
 *                           90    
 *            (Given Binary Search Tree)
 */
#include <stdio.h>
#include <stdlib.h> 
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
typedef struct btnode N;
N* bst(int arr[], int first, int last);
N* new(int val);
void display(N *temp);
 
int main()
{   
    int arr[] = {10, 20, 30, 40, 60, 80, 90};
    N *root = (N*)malloc(sizeof(N));  
    int n = sizeof(arr) / sizeof(arr[0]), i;
 
    printf("Given sorted array is\n");
    for (i = 0;i < n;i++)
        printf("%d\t", arr[i]);
    root = bst(arr, 0, n - 1); 
    printf("\n The preorder traversal of binary search tree is as follows\n");
    display(root);
    printf("\n");   
    return 0;
}
 
/* To create a new node */
N* new(int val)
{
    N* node = (N*)malloc(sizeof(N));
 
    node->value = val;
    node->l = NULL;
    node->r  =  NULL;
    return node;
}
 
/* To create a balanced binary search tree */
N* bst(int arr[], int first, int last)
{
    int mid;
    N* temp = (N*)malloc(sizeof(N));
    if (first > last)
        return NULL;
    mid = (first + last) / 2;
    temp = new(arr[mid]);
    temp->l = bst(arr, first, mid - 1);
    temp->r = bst(arr, mid + 1, last);
    return temp;
}




////////////////////* C Program to Find the Common Ancestor and Print the Path
 *
 *                       10
 *                       /  \                    
 *                      7    15
 *                     / \   / \
 *                    6   8 12  18
 *                   /     \
 *                  5         9
 *               (Given Binary tree) 
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
typedef struct btnode N;
 
N* new(int);
int count;
 
void create();
void preorder(N *t);
void ancestor(N *t);
int search(N *t, int, int);
void path(int, int, int);
 
N *root = NULL;
 
void main()
{
    int choice;
 
    create();
    while (1)
    {
        printf("Enter the choice\n");
        printf("1-Display : 2-path : 3-Exit\n");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            printf("preorder display of tree elements\n");
            preorder(root);
            printf("\n");
            break;
        case 2:
            ancestor(root);    
            break;
        case 3:
            exit(0);
        default:
            printf("Enter the right choice\n");
        }
    }
}
 
/* creating temporary node */
N* new(int data)
{
    N* temp = (N*)malloc(sizeof(N));
    temp->value = data;
    temp->l = NULL;
    temp->r = NULL;
 
    return(temp);
}
 
/* Creating the binary search tree */
void create()
{
    root = new(10);
    root->l = new(7);
    root->r = new(15);
    root->l->l = new(6);
    root->l->r = new(8);
    root->r->l = new(12);
    root->r->r = new(18);
    root->r->r->r = new(20);
    root->l->l->l = new(5);
    root->l->r->r = new(9);
}
 
/* To display the preorder traversal of the tree */
void preorder(N *temp)
{
        printf("%d->", temp->value);
        if (temp->l != NULL)
            preorder(temp->l);
        if (temp->r != NULL)
            preorder(temp->r);
}
 
/* to find common ancestor for given nodes */
void ancestor(N *temp)
{
    int a, b, anc = 0;
    count = 0;
 
    printf("enter two node values to find common ancestor\n");
    scanf("%d", &a);
    scanf("%d", &b);
    count = search(root, a, b);
    if (count  == 2)
    {
        while (temp->value != a && temp->value != b)
        {
            if ((temp->value > a)&&(temp->value > b))
            { 
                anc = temp->value;
                temp = temp->l;
            }
            else if ((temp->value < a)&&(temp->value < b))
            {
                anc = temp->value;
                temp = temp->r;
            }
            else if ((temp->value > a)&&(temp->value < b))
            {
                anc = temp->value;            
                printf("anc = %d\n", anc);
                break;
            }
            else if ((temp->value < a)&&(temp->value > b))
            {
                anc = temp->value;
                temp = temp->r;    
            }
            else
            {
                printf("common ancestor = %d\n", anc);
                break;
            }
        }
    path(anc, a, b);
    }
    else
        printf("enter correct node values & do not enter root value\n");
}
 
/* to find whether given nodes are present in tree or not */
int search(N *temp, int a, int b)
{
    if ((temp->value  == a ||temp->value  == b)&& (root->value != a&&root->value != b))
    {
        count++;        
    }
    if (temp->l != NULL)
        search(temp->l, a, b);
    if (temp->r != NULL)
        search(temp->r, a, b);
    return count;
}
 
/* to print the path ancestor to given nodes */
void path(int anc, int c, int b)
{
    N *temp = NULL;
    int i = 0, a[2];
    a[0] = c;
    a[1] = b;
 
    for (;i < 2;i++)
    {
        if (anc == root->value)    // If ancestor is root
        {
            temp = root;
            while (1)
            {
                printf("%d", temp->value);
                if (a[i] < temp->value)
                    temp = temp->l;
                else if (a[i] > temp->value)
                    temp = temp->r;
                else
                {
                    if (a[i] == temp->value)
                    {
                        break;
                    }
                }
                printf("->");
            }
            printf("\n");
        }
        else if (anc < root->value)    //If ancestor is less than the root value
        {
            temp = root;
            while (temp != NULL)
            {
                if (anc < temp->value)
                    temp = temp->l;
                else if (anc > temp->value)
                    temp = temp->r;
                else
                {
                    while (1)
                    {
                        if (a[i] < temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->l;
                        }
                        else if (a[i] > temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->r;
                        }
                        else
                        {
                            printf("%d\n", temp->value);
                            break;
                        }
                    }
                }
            }
        }
        else //If ancestor greater than the root value
        {
            temp = root;
            while (temp != NULL)
            {
                if (anc > temp->value)
                    temp = temp->r;
                else if (anc < temp->value)
                    temp = temp->l;
                else
                {
                    while (1)
                    {
                        if (a[i] < temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->l;
                        }
                        else if (a[i] > temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->r;
                        }
                        else
                        {
                            printf("%d\n", temp->value);
                            break;
                        }
                    }
                }
            }
        }
    }
}
 
/* To display the preorder */
void display(N *temp)
{
    printf("%d->", temp->value);
    if (temp->l != NULL)
        display(temp->l);
    if (temp->r != NULL)
        display(temp->r);
}


3. C Examples dealing with the Nodes of a Tree


*
///////////////////// * C Program to Count Number of Leaf Nodes in a Tree 
 
       50
      /  \
     20   30
    /  \    
   70  80
  /  \    \
 10     40     60    
(50,20,30,70,80,10,40,60)
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    struct btnode * l;
    struct btnode * r;
};
 
typedef struct btnode bt;
 
bt *root;
bt *new, *list;
int count = 0;
 
bt * create_node();
void display(bt *);
void construct_tree();
void count_leaf(bt *);
 
void main()
{
    construct_tree();
    display(root);
    count_leaf(root);
    printf("\n leaf nodes are : %d",count);
}
 
/* To create a empty node */
bt * create_node()
{
    new = (bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
}
 
/* To construct a tree */
void construct_tree()
{
    root = create_node();
    root->value = 50;
    root->l = create_node();
    root->l->value = 20;
    root->r = create_node();
    root->r->value = 30;
    root->l->l = create_node();
    root->l->l->value = 70;
    root->l->r = create_node();
    root->l->r->value = 80;
    root->l->r->r = create_node();
    root->l->r->r->value = 60;
    root->l->l->l = create_node();
    root->l->l->l->value = 10;
    root->l->l->r = create_node();
    root->l->l->r->value = 40; 
}
 
/* To display the elements in a tree using inorder */
void display(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    display(list->l);
    printf("->%d", list->value);
    display(list->r);
}
 
/* To count the number of leaf nodes */
void count_leaf(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    if (list->l == NULL && list->r == NULL)
    {
        count++;
    }
    count_leaf(list->l);
    count_leaf(list->r);
}

/* 
///////////////////////////// * C Program to Find Nodes which are at Maximum Distance in Binary Tree
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *r,*l;
} *root = NULL, *temp = NULL;
 
void create();
void insert();
void add(struct btnode *t);
void maxdistance(struct btnode *t);
 
int count = 0, max = 0, v[100] = {0}, z = 0, max2, max1[100] = {0};
 
void main()
{
    int ch, i;
 
    printf("Program to find nodes at maximum distance");
    printf("\n  OPERATIONS ----"); 
    printf("\n1] Insert ");
    printf("\n2] Display nodes ");
    printf("\n3] Exit ");    
    while (1)
    {                        
        printf("\nEnter your choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:    
            insert();
            break;
        case 2:    
            max = 0;
            count = 0;
            maxdistance(root);
        for (i = 1; i < z; i++)
        {
            max2 = max1[0];
            if (max2 < max1[i])
                max2 = max1[i];
        }
        printf("Maximum distance nodes \nNodes\t Distance "); 
        for (i = 0; i < z; i++)
        {
            if (max2 == max1[i])
                printf("\n %d\t  %d ",v[i],max2);        
        }
        break;
        case 3: 
            exit(0);
        default :     
            printf("Wrong choice, Please enter correct choice  ");
            break;    
        }
    }
}
 
/* To create a new node with the data from the user */
void create()
{
    int data;
 
    printf("Enter the data of node : ");
    scanf("%d", &data);
    temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* To check for root node and then create it */
void insert()
{
    create();
 
    if (root == NULL)
        root = temp;
    else
        add(root);
}
 
/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
    if ((temp->value > t->value) && (t->r!=NULL))    /* value more than root node value insert at right */
        add(t->r);
    else if ((temp->value > t->value) && (t->r==NULL))
        t->r = temp;
    else if ((temp->value < t->value) && (t->l!=NULL))   /* value less than root node value insert at left */
        add(t->l);
    else if ((temp->value < t->value) && (t->l==NULL))
        t->l = temp;
}
 
/* Function to find the max distance nodes */
void maxdistance(struct btnode *t)
{
    if (t->l!=NULL)
    {
        count++;            /* to count the number of nodes in between root and leaf */
        maxdistance(t->l);
    }
    if (max < count)
        max = count;
    if (max == count)
    {
        max1[z] = max;
        v[z] = t->value;
        z++;
    }
    if (t->r != NULL)
    {
        count++;        
        maxdistance(t->r);
    }
    count--;
}


* C Program to Print Border of given Tree in Anticlockwise Direction 
 *              50
 *             /  \
 *            20  30
 *           /  \
 *          70  80
 *         / \    \
 *       10  40   60                                
 */            
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    struct btnode *l;
    struct btnode *r;
};
struct btnode *root;
typedef struct btnode bt;
bt *new, *ptr, *ptr1, *ptr2;
 
void print();
void print_leaf_nodes(bt*);
void print_right_recursive(bt*);
bt* create();
void construct_binary_tree();
 
void main()
{
    construct_binary_tree();
    printf("\nprinting the border elements anticlockwise direction:\n");
    print();
    printf("\n");
}
 
bt* create()
{
    new = (bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
    return new;
}
 
void construct_binary_tree()
{
    root = create();
    root->value = 50;
 
    ptr = create();
    root->l = ptr;
    ptr->value = 20;
    ptr1 = create();
    ptr->l = ptr1;
    ptr1->value = 70;
    ptr2 = create();
    ptr1->l = ptr2;
    ptr2->value = 10;
    ptr2 = create();
    ptr1->r = ptr2;
    ptr2->value = 40;
    ptr1 = create();
    ptr->r = ptr1;
    ptr1->value = 80;
    ptr2 = create();
    ptr1->r = ptr2;
    ptr2->value = 60;
    ptr = create();
    root->r = ptr;
    ptr->value = 30;
}
 
void print()
{
    ptr = root;
    while (ptr->l != NULL)
    {
        printf("->%d", ptr->value);
        ptr = ptr->l;
    }
    ptr = root;
    print_leaf_nodes(ptr);
    ptr = root;
    print_right_recursive(ptr);
}
 
void print_leaf_nodes(bt* ptr)
{
    if (ptr != NULL)
    {
        if (ptr->l == NULL && ptr->r == NULL)
        {
            printf("->%d", ptr->value);
        }
        else
        {
            print_leaf_nodes(ptr->l);
            print_leaf_nodes(ptr->r);
        }
    }
    else
        return;
}
 
void print_right_recursive(bt* ptr)
{
    int val;
    ptr = ptr->r;
    if (ptr->r != NULL)
    {    
        print_right_recursive(ptr->r);
        printf("->%d", ptr->value);
    }
    else
    {
        return;
    }
}



/* 
 ////////////////////////////* C Program to Count Number of Non Leaf Nodes of a given Tree
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *r,*l;
} *root = NULL, *temp = NULL;
 
void create();
void insert();
void add(struct btnode *t);
void inorder(struct btnode *t);
 
int count = 0;
 
void main()
{
    int ch;
 
    printf("\nOPERATIONS ---");
    printf("\n1] Insert ");
    printf("\n2] Display");
    printf("\n3] Exit ");    
 
    while (1)
    {                        
        printf("\nEnter your choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:    
            insert();
            break;
        case 2: 
            inorder(root);
            printf("\nNumber of non leaf nodes: %d", count);
            break;
        case 3: 
            exit(0);
        default :     
            printf("Wrong choice, Please enter correct choice  ");
            break;    
        }
    }
}
 
/* To create a new node with the data from the user */
void create()
{
    int data;
 
    printf("Enter the data of node : ");
    scanf("%d", &data);
    temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* To check for root node and then create it */
void insert()
{
    create();
 
    if (root == NULL)
        root = temp;
    else
        add(root);
}
 
/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
    if ((temp->value > t->value) && (t->r != NULL))        /* value more than root node value insert at right */
        add(t->r);
    else if ((temp->value > t->value) && (t->r == NULL))
        t->r = temp;
    else if ((temp->value < t->value) && (t->l != NULL))        /* value less than root node value insert at left */
        add(t->l);
    else if ((temp->value < t->value) && (t->l == NULL))
        t->l = temp;
}
 
/* To display and count the sum of non leaf nodes */
void inorder(struct btnode *t)
{
    if (t->l != NULL)
        inorder(t->l);
    if ((t->l != NULL) ||  (t->r != NULL))
    {
        count++;                            /* To count number of non leaf nodes */
        printf("%d ->",t->value);
    }
    if (t->r != NULL)
        inorder(t->r);
}




C Examples on Special Properties of Binary Trees


/*
 * C Program to Check whether a Tree and its Mirror Image are same
 *                        50                               50
 *                       /  \                             /  \
 *                      20     30                        30   20
 *  Sample Tree<------ /  \                                  /  \   ----------> Mirror image
 *                    70      80                            80   70
 *                   /  \    \                             /    /  \  
 *                  10  40     60                        60   40   10
 *                             (50,20,30,70,80,10,40,60)                                  
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    struct btnode * l;
    struct btnode * r;
};
 
typedef struct btnode bt;
 
bt *root,*temp;
bt *new;
int c;
 
bt * create_node();
void display(bt *);
bt * construct_tree();
void mirror_image(bt *);
int compare(bt *,bt *);
 
void main()
{
    root = construct_tree();
    display(root);
    temp = construct_tree();
    mirror_image(temp);
    printf("\n mirror image:\n");
    display(temp);
    c = compare(root,temp);
    if (c)
    {
        printf("\nsame");
    }
    else
    {
        printf("\nnot same");
    }
}
 
/* creates new node */
bt * create_node()
{
    new=(bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
}
 
/* constructs the tree */
bt * construct_tree()
{
    bt *list;
 
    list = create_node();
    list->value = 50;
    list->l = create_node();
    list->l->value = 20;
    list->r = create_node();
    list->r->value = 30;
    list->l->l = create_node();
    list->l->l->value = 70;
    list->l->r = create_node();
    list->l->r->value = 80;
    list->l->r->r = create_node();
    list->l->r->r->value = 60;
    list->l->l->l = create_node();
    list->l->l->l->value = 10;
    list->l->l->r = create_node();
    list->l->l->r->value = 40;
 
    return list;    
}
 
/* displays the tree using inorder */
void display(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    display(list->l);
    printf("->%d", list->value);
    display(list->r);
}
 
/* creates mirror image of a tree */
void mirror_image(bt * list)
{
    bt * temp1;
 
    if (list == NULL)
    {
        return;
    }
    temp1 = list->l;
    list->l = list->r;
    list->r = temp1;
    mirror_image(list->l);
    mirror_image(list->r);
}
 
/* compares tree and its mirror image */
int compare(bt *list, bt * list1)
{
    int d;
    if (list == NULL && list1 == NULL)
    {
        return 1;
    }
    else if (list != NULL && list1 != NULL)
    {
        return(list->value == list1->value &&
        compare(list->l, list1->l) &&
        compare(list->r, list1->r));
    }
    else
    {
        return 0;
    }
}


 * C Program to Create a Mirror Copy of a Tree and Display using 
 * BFS Traversal
 *                    40
 *                    /\
 *                   20 60
 *                   /\  \
 *                  10 30  80
 *                          \
 *                           90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{ 
    int value; 
    struct btnode *left, *right; 
}; 
typedef struct btnode node;
 
/* function prototypes */
void insert(node *, node *);
void mirror(node *);
 
/* global variables */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];
 
void main() 
{ 
    node *new = NULL ; 
    int num = 1; 
    printf("Enter the elements of the tree(enter 0 to exit)\n"); 
    while (1) 
    {     
        scanf("%d",  &num); 
        if (num == 0) 
            break; 
        new = malloc(sizeof(node)); 
        new->left = new->right = NULL; 
        new->value = num; 
        if (root == NULL) 
            root = new; 
        else 
        { 
            insert(new, root); 
        } 
    }
    printf("mirror image of tree is\n"); 
    queue[++rear] = root->value;
    mirror(root);
    for (i = 0;i <= rear;i++)
        printf("%d -> ", queue[i]);
    printf("%d\n", root->right->right->right->value);
}
 
/* inserting nodes into the tree */
void insert(node * new , node *root) 
{ 
    if (new->value > root->value) 
    {     
        if (root->right == NULL) 
            root->right = new; 
        else 
            insert (new, root->right); 
    } 
    if (new->value < root->value) 
    {     
        if (root->left == NULL) 
            root->left = new; 
        else 
            insert (new, root->left); 
    }     
}
 
/* mirror image of nodes */
void mirror(node *root)
{
    val = root->value;
    if ((front <= rear) && (root->value == queue[front])) 
    {
        if (root->right != NULL || root->right == NULL)
            queue[++rear] = root->right->value;
        if (root->left != NULL)
            queue[++rear] = root->left->value;
        front++;
    }
    if (root->right != NULL)
    {
        mirror(root->right);
    }
    if (root->left != NULL)
    {
        mirror(root->left);
    }
}



/*
//////////////////////////////////////////// * C Program to Find the Nearest Common Ancestor in the Given set 
 * of Nodes 
 */
#include <stdio.h>
#include <stdlib.h>
 
/*
 * Structure of binary tree node
 */
struct btnode 
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
void createbinary();
node* add(int val);
int height(node *);
int nearest_common_ancestor(node*,  int,  int);
typedef struct btnode node;
node *root = NULL, *ptr;
 
int  main()
{
    int c, n1, n2;
 
    createbinary();
    printf("\nEnter nodes having common ancestor");
    scanf("%d %d", &n1, &n2);
    c = nearestcommonancestor(root, n1, n2);
    if (c == -1)
    {
        printf("No common ancestor");
    }
    else
    {
        printf("The common ancestor is %d", c);
    }
}
/*
 * constructing the following binary tree
 *     50
 *     / \
 *    20 30
 *   / \ 
 *  70 80
 * / \     \
 *10 40      60
 */    
void createbinary()
{
    root = add(50);
    root->l = add(20);
    root->r = add(30);
    root->l->l = add(70);
    root->l->r = add(80);
    root->l->l->l = add(10);
    root->l->l->r = add(40);
    root->l->r->r = add(60);
}
 
/*
 * Add node to binary tree
 */
node* add(int val)
{
    ptr = (node*)malloc(sizeof(node));
    if (ptr == NULL)
    {
        printf("Memory was not allocated");
        return;
    }
    ptr->value = val;
    ptr->l = NULL;
    ptr->r = NULL;
    return ptr;
}
 
/*
 * height of the binary tree
 */
int height(node *n)
{
    int lheight, rheight;
 
    if (n != NULL)
    {
        lheight = height(n->l);
        rheight = height(n->r);
        if (lheight > rheight)
            return(lheight + 1);
        else 
            return(rheight + 1);
    }
}
 
/*
 * Finds the nearest common ancestor
 */
int nearestcommonancestor(node *temp, int n1, int n2)
{
    int h, i, j, k;
    node *prev;
 
    /*
     * If any one the inputted node is root then no common ancestor
     */
    if (n1 == root->value || n2 == root->value)
    {
        return - 1;    
    }
    h = height(root);    
    for (i = 1;i < h;i++)
    {
        if (temp->l->value == n1 || temp->r->value == n1 || temp ->l->value == n2 || temp->r->value == n2)
        {
            prev = temp;
            for (j = 1, temp = root;j < h;j++)
            {
                if (temp != NULL)
                {
                    if (temp->r->value == n2 || temp->r->value == n1 || temp->l->value == n1 || temp->l->value == n2)
                    {
                        /*
                         * If the parent of n1 and parent of n2 are same then the value of parent is returned
                         */
                        if (prev->value == temp->value)
                            return prev->value;
                        /*
                         * otherwise from parents of two nodes is traversed upward if any node matches with other's node parent then that is 
                         * considered as common ancestor
                         */
                        else
                            for (k = 0, prev = temp;k < h;k++)
                            {
                                if (temp->l->value == prev->l->value)
                                    return temp->value;
                                else 
                                    temp = temp->l;
                            }
                    }
                }
                temp = temp->l;
            }
        }
        temp = temp->l;
    }
}




* C Program to Find the Common Ancestor and Print the Path
 *
 *                       10
 *                       /  \                    
 *                      7    15
 *                     / \   / \
 *                    6   8 12  18
 *                   /     \
 *                  5         9
 *               (Given Binary tree) 
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
typedef struct btnode N;
 
N* new(int);
int count;
 
void create();
void preorder(N *t);
void ancestor(N *t);
int search(N *t, int, int);
void path(int, int, int);
 
N *root = NULL;
 
void main()
{
    int choice;
 
    create();
    while (1)
    {
        printf("Enter the choice\n");
        printf("1-Display : 2-path : 3-Exit\n");
        scanf("%d", &choice);
        switch (choice)
        {
        case 1:
            printf("preorder display of tree elements\n");
            preorder(root);
            printf("\n");
            break;
        case 2:
            ancestor(root);    
            break;
        case 3:
            exit(0);
        default:
            printf("Enter the right choice\n");
        }
    }
}
 
/* creating temporary node */
N* new(int data)
{
    N* temp = (N*)malloc(sizeof(N));
    temp->value = data;
    temp->l = NULL;
    temp->r = NULL;
 
    return(temp);
}
 
/* Creating the binary search tree */
void create()
{
    root = new(10);
    root->l = new(7);
    root->r = new(15);
    root->l->l = new(6);
    root->l->r = new(8);
    root->r->l = new(12);
    root->r->r = new(18);
    root->r->r->r = new(20);
    root->l->l->l = new(5);
    root->l->r->r = new(9);
}
 
/* To display the preorder traversal of the tree */
void preorder(N *temp)
{
        printf("%d->", temp->value);
        if (temp->l != NULL)
            preorder(temp->l);
        if (temp->r != NULL)
            preorder(temp->r);
}
 
/* to find common ancestor for given nodes */
void ancestor(N *temp)
{
    int a, b, anc = 0;
    count = 0;
 
    printf("enter two node values to find common ancestor\n");
    scanf("%d", &a);
    scanf("%d", &b);
    count = search(root, a, b);
    if (count  == 2)
    {
        while (temp->value != a && temp->value != b)
        {
            if ((temp->value > a)&&(temp->value > b))
            { 
                anc = temp->value;
                temp = temp->l;
            }
            else if ((temp->value < a)&&(temp->value < b))
            {
                anc = temp->value;
                temp = temp->r;
            }
            else if ((temp->value > a)&&(temp->value < b))
            {
                anc = temp->value;            
                printf("anc = %d\n", anc);
                break;
            }
            else if ((temp->value < a)&&(temp->value > b))
            {
                anc = temp->value;
                temp = temp->r;    
            }
            else
            {
                printf("common ancestor = %d\n", anc);
                break;
            }
        }
    path(anc, a, b);
    }
    else
        printf("enter correct node values & do not enter root value\n");
}
 
/* to find whether given nodes are present in tree or not */
int search(N *temp, int a, int b)
{
    if ((temp->value  == a ||temp->value  == b)&& (root->value != a&&root->value != b))
    {
        count++;        
    }
    if (temp->l != NULL)
        search(temp->l, a, b);
    if (temp->r != NULL)
        search(temp->r, a, b);
    return count;
}
 
/* to print the path ancestor to given nodes */
void path(int anc, int c, int b)
{
    N *temp = NULL;
    int i = 0, a[2];
    a[0] = c;
    a[1] = b;
 
    for (;i < 2;i++)
    {
        if (anc == root->value)    // If ancestor is root
        {
            temp = root;
            while (1)
            {
                printf("%d", temp->value);
                if (a[i] < temp->value)
                    temp = temp->l;
                else if (a[i] > temp->value)
                    temp = temp->r;
                else
                {
                    if (a[i] == temp->value)
                    {
                        break;
                    }
                }
                printf("->");
            }
            printf("\n");
        }
        else if (anc < root->value)    //If ancestor is less than the root value
        {
            temp = root;
            while (temp != NULL)
            {
                if (anc < temp->value)
                    temp = temp->l;
                else if (anc > temp->value)
                    temp = temp->r;
                else
                {
                    while (1)
                    {
                        if (a[i] < temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->l;
                        }
                        else if (a[i] > temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->r;
                        }
                        else
                        {
                            printf("%d\n", temp->value);
                            break;
                        }
                    }
                }
            }
        }
        else //If ancestor greater than the root value
        {
            temp = root;
            while (temp != NULL)
            {
                if (anc > temp->value)
                    temp = temp->r;
                else if (anc < temp->value)
                    temp = temp->l;
                else
                {
                    while (1)
                    {
                        if (a[i] < temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->l;
                        }
                        else if (a[i] > temp->value)
                        {
                            printf("%d->", temp->value);
                            temp = temp->r;
                        }
                        else
                        {
                            printf("%d\n", temp->value);
                            break;
                        }
                    }
                }
            }
        }
    }
}




//////////*
 * C Program to Print all the Elements of Nth Level in Single Line 
 */
#include <stdio.h>
#include <stdlib.h>
 
/*
 * structure of node
 */
struct btnode 
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
void createbinary();
node* add(int val);
int height(node *);
void printlevel(node *, int, int);
void print();
 
typedef struct btnode node;
node *root = NULL, *ptr;
 
int  main()
{
    int c;
 
    createbinary();
    print();
}
/*
 * constructing the following binary tree
 *     50
 *     / \
 *    20 30
 *   / \ 
 *  70 80
 * / \     \
 *10 40      60
 */    
void createbinary()
{
    root = add(50);
    root->l = add(20);
    root->r = add(30);
    root->l->l = add(70);
    root->l->r = add(80);
    root->l->l->l = add(10);
    root->l->l->r = add(40);
    root->l->r->r = add(60);
}
 
/*
 * Adding node to binary tree
 */
node* add(int val)
{
    ptr = (node*)malloc(sizeof(node));
    if (ptr == NULL)
    {
        printf("Memory was not allocated");
        return;
    }
    ptr->value = val;
    ptr->l = NULL;
    ptr->r = NULL;
    return ptr;
}
 
/*
 * Prints all the nodes of all levels of the binary tree
 */
void print()
{
    int h, i;
 
    h = height(root);
    for (i = 0;i < h;i++)
    {
        printf("\nLEVEL %d  :", i);
        printlevel(root, i, 0);
        printf("\n");
    }
}
/*
 *Prints the nodes of a particular level
 */
void printlevel(node *n, int desired, int current)
{
    if (n)
    {
        if (desired == current)
            printf("%d\t", n->value);
        else
        {
            printlevel(n->l, desired, current + 1);
            printlevel(n->r, desired, current + 1);
        }
    }
}
 
/*
 * Height of the binary tree
 */
int height(node *n)
{
    int lheight, rheight;
    if (n != NULL)
    {
        lheight = height(n->l);
        rheight = height(n->r);
        if (lheight > rheight)
            return(lheight+1);
        else 
            return(rheight+1);
    }
}



/*
 * C Program to Convert Binary Tree to Binary Search Tree 
 */
#include <stdio.h>
#include <stdlib.h>
 
/*
 * Structure of the binary tree
 */
struct btnode 
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
void createbinary();
void inorder(node *);
int count(node*);
node* add(int );
void sort();
void binary_to_bst(node *);
int compare(const void *,const void *);
void inorder_to_array(node*,int[],int *);
void array_to_bst(int *arr,node *,int *);
void display_bst(node *);
void print();
void print_level(node*,int,int);
int height(node*);
 
typedef struct btnode node;
node *root = NULL,*ptr;
 
int data[10];
int i = 0;
 
int  main()
{
    createbinary();
    binary_to_bst(root);
    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("\nThe inorder of binary search tree\n");
    inorder(root);
    printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
    printf("\n================================================");
    printf("\nThe nodes of a binary search tree (LEVEL WISE)");
    printf("\n=================================================");
    print();
}
/*
 * constructing the following binary tree
 *     50
 *     / \
 *    20 30
 *   / \ 
 *  70 80
 * / \     \
 *10 40      60
 */    
void createbinary()
{
    root = add(50);
    root->l = add(20);
    root->r = add(30);
    root->l->l = add(70);
    root->l->r = add(80);
    root->l->l->l = add(10);
    root->l->l->r = add(40);
    root->l->r->r = add(60);
}
 
/*
 * Adds a node to the tree
 */
node* add(int val)
{
    ptr = (node*)malloc(sizeof(node));
    if (ptr == NULL)
    {
        printf("Memory was not allocated");
        return 0;
    }
    ptr->value = val;
    ptr->l = NULL;
    ptr->r = NULL;
    return ptr;
}
 
/*
 * Store the inorder of binary tree
 */
void inorder_to_array(node *n,int data[],int *ptr)
{
    if (n != NULL)
    {
        inorder_to_array(n->l,data,ptr);
        data[*ptr] = n->value;
        (*ptr)++;
        inorder_to_array(n->r,data,ptr);
    }
} 
 
/*
 * counting the number of nodes in a tree
 */
int count(node *n)
{
    int c = 1;
 
    if (n == NULL)
        return 0;
    else
    {
        c += count(n->l);
        c += count(n->r);
        return c;
    }
}
/*
 *Display inorder of the BST
 */
void inorder(node *root)
{
    if (root != NULL)
    {
        inorder(root->l);
        printf("%d->", root->value);
        inorder(root->r);
    }
 
}
/*
 * print the nodes of the BST for all levels until height of the tree is reached
 */
 
void print()
{
    int h, i;
 
    h = height(root);
    for(i = 0;i < h;i++)
    {
        printf("\nLEVEL %d  :", i);
        print_level(root, i, 0);
        printf("\n");
    }
}
 
/*
 * print the nodes of the BST for a particular level
 */
void print_level(node *n, int desired, int current)
{
    if (n)
    {
        if (desired == current)
        {    
            printf("  %5d", n->value);
        } 
        else
        {
            print_level(n->l, desired, current + 1);
            print_level(n->r, desired, current + 1);
        }
   }
}
 
/*
 * Height of binary tree
 */
int height(node *n)
{
    int lheight, rheight;
 
    if (n != NULL)
    {
        lheight = height(n->l);
        rheight = height(n->r);
        if (lheight > rheight)
            return(lheight + 1);
        else 
            return(rheight + 1);
    }
    else
    {
        return 0;
    }
}    
int compare(const void *a, const void *b)
{
    return *(int*)a-*(int*)b;
}
 
/*
 * copies the elements of array to binary tree
 */
void array_to_bst(int *arr, node *root, int *indexptr)
{
    if (root != NULL)
    {
        array_to_bst(arr,root->l, indexptr);
        root->value = arr[i++];
        array_to_bst(arr,root->r, indexptr);
    }
}
 
/*
 * Converting binary tree to binary search tree
 * storeinorder() function stores the inorder traversal of binary tree
 * qsort() sorts the inorder of binary tree
 * arraytobst() copies the elements of array to binary tree
 * Then binary tree converted to binary search tree
 */ 
 
void binary_to_bst(node *root)
{
    int n, i;
 
    if (root == NULL)
        return;
    n = count(root);
    i = 0;
    inorder_to_array(root, data, &i);
    qsort(&data, n, sizeof(data[0]), compare);
    i = 0;
    array_to_bst(data, root, &i);
}

 C Program to find the Total Columns/Vertical Lines of a given 
 * Binary Search Tree
 
    40
   /  \
  20   60
 /  \    \
10  30   80
          \
          90
(40,60,80,20,30,90,10)    
(Binary search tree)         
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    int col;
    struct btnode *l;
    struct btnode *r;
};
 
typedef struct btnode bt;
 
bt *root,*temp;
bt *new;
int min = 0, max = 0;
 
bt * create_node();
void display(bt *);
void insert(bt *, bt *);
void columns(bt *);
 
void main()
{
    int num;
 
    while (1)
    {
        printf("enter the number:");
        scanf("%d", &num);
        if (num == 0)
        {
            break;
        }
        create_node();
        new->value = num;
        if (root == NULL)
        {
            root = new;
            root->col = 0;
        }
        else
        {
            insert(new,root);
        }    
    }
    display(root);
    columns(root);
    printf("\n total number of columns : %d",-min + max + 1);
}
 
/* creates new node */
bt * create_node()
{
    new=(bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
}
 
/* inserts the node into tree */
void insert(bt * new , bt * list)
{
    if (new->value>list->value)
    {
        if (list->r == NULL)
        {
            list->r = new;
            new->col = list->col + 1;
        }
        else
        {
            insert (new,list->r);
        }        
    }
    if (new->value < list->value)
    {
        if (list->l == NULL)
        {
            list->l = new;
            new->col = list->col - 1;
        }
        else
        {
            insert (new,list->l);
        }
    }
}
 
/* displays the elements in the tree using inorder */
void display(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    display(list->l);
    printf("->%d", list->value);
    display(list->r);    
}
 
/* counts the number of columns in tree */
void columns(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    if (list->col < min)
    {
        min = list->col;
    }
    if (list->col > max)
    {
        max = list->col;
    }
    columns(list->l);
    columns(list->r);
}


*
 ///////////////////////* C Program to Find the Sum of all Nodes in a Tree
 *
 *        50
 *        / \
 *     20  30
 *    / \
 *   70  80
 *   / \   \
 *  10 40   60
 *
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root = NULL, *ptr, *temp;
 
// Function Prototypes
int find_depth(struct btnode *);
int modify_tree(struct btnode *);
void printout(struct btnode *);
struct btnode* newnode(int);
 
void main()
{
    int d;
 
    root  =  newnode(50);
    root->l  =  newnode(20);
    root->r  =  newnode(30);
    root->l->l  =  newnode(70);
    root->l->r  =  newnode(80);
    root->l->r->r  =  newnode(60);
    root->l->l->l  =  newnode(10);
    root->l->l->r  =  newnode(40);
    printout(root);
    ptr = root;
    d = find_depth(ptr);
    printf("Depth of tree is %d\n",d);
    printf("tree elements after modification are ----\n");
    modify_tree(ptr);
    printout(ptr);
}
 
// Create a node
struct btnode* newnode(int value)
{
    struct btnode* node  =  (struct btnode*)malloc(sizeof(struct btnode));
    node->value  =  value;
    node->l  =  NULL;
    node->r  =  NULL;
    return(node);
}
 
// Function to find depth of a tree
int find_depth(struct btnode* tree)
{
    int ldepth, rdepth;
 
    if (tree == NULL)
        return 0;
    else
    {
        ldepth = find_depth(tree->l);
        rdepth = find_depth(tree->r);
        if (ldepth > rdepth)
            return ldepth + 1;
        else
            return rdepth + 1;
    }
}
 
// Function to modify the tree
int modify_tree(struct btnode *tree)
{
    int i, original;
 
    if (tree == NULL)
        return 0;
    original = tree->value;
    tree->value = modify_tree(tree->l) + modify_tree(tree->r);
    return tree->value + original;
}
 
// Function to print the elements of tree
void printout(struct btnode *tree)
{
    if (tree->l)
        printout(tree->l);
    printf("%d\n", tree->value);
    if (tree->r)
        printout(tree->r);
}


/*
 * C Program to Construct a Tree & Perform Insertion, Deletion, Display 
 */ 
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root = NULL;
 
// Function Prototype
void printout(struct btnode*);
struct btnode* newnode(int);
 
void main()
{
    root=newnode(50);
    root->l=newnode(20);
    root->r=newnode(30);
    root->l->l=newnode(70);
    root->l->r=newnode(80);
    root->l->r->r=newnode(60);
    root->l->l->l=newnode(10);
    root->l->l->r=newnode(40);
    printf("tree elements are\n");
    printf("\nDISPLAYED IN INORDER\n");
    printout(root);
    printf("\n");
}
 
// Create a node
struct btnode* newnode(int value)
{
    struct btnode* node = (struct btnode*)malloc(sizeof(struct btnode));
    node->value = value;
    node->l = NULL;
    node->r = NULL;
    return(node);
}
 
// to display the tree in inorder
void printout (struct btnode *tree)
{
    if (tree->l)
        printout(tree->l);
    printf("%d->", tree->value);
    if (tree->r)
        printout(tree->r);
}

/*
 * C Program to Check whether a Tree is a Binary Search Tree 
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int data;
    struct node* left;
    struct node* right;
};
 
static struct node *prev = NULL; 
 
/*Function to check whether the tree is BST or not*/
int is_bst(struct node* root)
{
    if (root)
    {
        if (!is_bst(root->left)) //moves towards the leftmost child of the tree and checks for the BST
            return 0;
        if (prev != NULL && root->data <= prev->data)
            return 0;
        prev = root;
        return is_bst(root->right);    //moves the corresponding right child of the tree and checks for the BST
    }
    return 1;
}
 
struct node* newNode(int data)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
 
    return(node);
}
 
int main()
{
  /*
    The input tree is as shown below
                40
                / \
            20        60
            / \       \
        10        30      80
                          \
                            90
  */
    struct node *root = newNode(40);
    root->left        = newNode(20);
    root->right       = newNode(60);
    root->left->left  = newNode(10);
    root->left->right = newNode(30);
    root->right->right = newNode(80);
    root->right->right->right = newNode(90);
    if (is_bst(root))
        printf("TREE 1 Is BST");
    else
        printf("TREE 1 Not a BST");
    prev = NULL;
/*
    The input tree is as shown below
                50
                / \
            20        30
            / \      
        70        80 
        / \          \
    10     40     60
*/
    struct node *root1 = newNode(50);
    root1->left  = newNode(20);
    root1->right  = newNode(30);
    root1->left->left  = newNode(70);
    root1->left->right = newNode(80);
    root1->left->left->right = newNode(40);
    root1->left->left->leftt = newNode(90);
    if (is_bst1(root1))
        printf("TREE 2 Is BST");
    else
        printf("TREE 2 Not a BST");
    return 0;
}



/*
 * C Program to Print all the Paths from the Root to the Leaf 
 * in a Tree 
 */
#include<stdio.h>
#include<stdlib.h>
 
struct node
{
   int data;
   struct node* left;
   struct node* right;
};
 
void print_paths_recur(struct node* node, int path[], int path_len);
void print_array(int ints[], int len);
 
/*Function to store all the paths from the root node to all leaf nodes in  a array*/
 
void print_paths(struct node* node) 
{
  int path[1000];
  print_paths_recur(node, path, 0);
}
 
/*Function which helps the print_path to recursively print all the nodes*/ 
void print_paths_recur(struct node* node, int path[], int path_len) 
{
  if (node == NULL) 
    return; 
 
  path[path_len] = node->data;
  path_len++;
 
  if (node->left == NULL && node->right == NULL) 
  {
    print_array(path, path_len);
  }
  else
  {
    print_paths_recur(node->left, path, path_len);    //recursively calls the left node of the tree
    print_paths_recur(node->right, path, path_len);    //recursively calls the right node of the tree
  }
}
 
/*Function to print all the paths */
void print_array(int ints[], int len) 
{
  int i;
  for (i = 0; i < len; i++) 
  {
    printf("%d -> ", ints[i]);
  }
  printf("\n");
}    
 
struct node* newnode(int data)
{
  struct node* node = (struct node*) malloc(sizeof(struct node));
  node->data = data;
  node->left = NULL;
  node->right = NULL;
 
  return(node);
}
 
int main()
{ 
   /*
    The input tree is as shown below
                40
                / \
            20        60
            / \       \
        10        30      80
                          \
                            90
  */ 
  struct node *root = newnode(40);
  root->left = newnode(20);
  root->right = newnode(60);
  root->left->left = newnode(10);
  root->left->right = newnode(30);
  root->right->right = newnode(80);
  root->right->right->right = newnode(90);
  print_paths(root);
  return 0;
}



/*
 * C Program to Print only Nodes in Left SubTree 
 */
#include <stdio.h>
#include <stdlib.h>
 
struct node
{
    int data;
    struct node* left;
    struct node* right;
};
 
int queue[100];
int front = 0, rear = 0, val; 
 
/*Function to traverse the tree using Breadth First Search*/
void bfs_traverse(struct node *node)
{
    val = node->data;
    if ((front< = rear)&&(node->data =  = queue[front]))
    {
        if (node->left != NULL)
            queue[rear++] = node->left->data;
        if (node->right != NULL)
            queue[rear++] = node->right->data;
        front++;
    }
    if (node->left != NULL)
    {
        bfs_traverse(node->left);
    }
    if (node->right != NULL)
    {
        bfs_traverse(node->right);
    }
}
 
struct node* newnode(int data)
{
    struct node* node  =  (struct node *)malloc(sizeof(struct node));
    node->data  =  data;
    node->left  =  NULL;
    node->right  =  NULL;
 
    return(node);
}
 
int main()
{ 
    int i;
 
    /*
    The input tree is as shown below
                40
                / \
            20        60
            / \       \
        10        30      80
                          \
                            90
    */
    struct node *root  =  newnode(40);
    root->left         =  newnode(20);
    root->right        =  newnode(60);
    root->left->left   =  newnode(10);
    root->left->right  =  newnode(30);
    root->right->right  =  newnode(80);
    root->right->right->right  =  newnode(90);
    queue[rear++] = root->left->data;
    bfs_traverse(root->left);
    for (i = 0;i < rear;i++)
        printf("%d->", queue[i]);
    return 0;
}


/* 
 * C Program to Find 2 Nodes with Longest Distance and Display 
 * using Inorder Traversal
 *             40
 *             /\
 *           20 60
 *           /\  \
 *         10 30  80
 *                 \
 *                  90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
   int value;
   struct btnode *left, *right;
};
typedef struct btnode node;
 
/* function prototypes */
void insert(node *, node *);
void inorder(node *);
int  height(node *);
 
node *temp, *root = NULL;
 
void main()
{
    node *new = NULL ;
    int num  = 1;
 
    printf("Enter the elements of the tree(enter 0 to exit)\n");
    while (1)
    {
        scanf("%d",  &num);
        if (num == 0)
            break;
        new  =  malloc(sizeof(node));
        new->left  =  new->right  =  NULL;
        new->value  =  num;
        if (root  == NULL)
            root  =  new;
        else
        {
            insert(new, root);
        }
    }
    printf("elements in a tree in inorder are\n");
    inorder(root);
    height(root);
}
 
/* displaying nodes of a tree using inorder */
void inorder(node *root)
{
    if (root != NULL)
    {
        inorder(root->left);
        printf("%d -> ", root->value);
        inorder(root->right);
    }
}
 
/* inserting nodes into a tree */
void insert(node * new , node *root)
{
    if (new->value>root->value)
    {
        if (root->right  == NULL)
            root->right  =  new;
        else
            insert(new, root->right);
    }
    if (new->value<root->value)
    {
        if (root->left  == NULL)
            root->left = new;
        else
            insert(new, root->left);
    }
}
 
/* to find the longest path */
int height(node *temp)
{
    temp = root;
 
    if (temp  == NULL)
        printf("tree is empty\n");
    else
    {
        printf("\nlongest path is\n");
        while (temp->left != NULL)
        {
            if (temp->left == NULL)
                temp = temp->right;
            else
                temp = temp->left;
        }
        printf("%d ->", temp->value);
        temp = root;
        while (temp->right != NULL)
        {
              if (temp->right  == NULL)
                temp = temp->left;
            else
                temp = temp->right;
        }
        printf(" %d", temp->value);
    }
}



/*
 * C Program to Display the Nodes of a Tree using BFS Traversal 
 *                 40
 *                 /\
 *                20 60
 *                /\  \
 *              10 30  80
 *                      \
 *                       90
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{ 
    int value; 
    struct btnode *left, *right; 
}; 
typedef struct btnode node;
 
/* function declarations */
void insert(node *, node *);
void bfs_traverse(node *);
 
/*global declarations */
node *root = NULL;
int val, front = 0, rear = -1, i;
int queue[20];
 
void main() 
{ 
    node *new = NULL ; 
    int num = 1; 
    printf("Enter the elements of the tree(enter 0 to exit)\n"); 
    while (1) 
    {     
        scanf("%d",  &num); 
        if (num  ==  0) 
            break; 
        new = malloc(sizeof(node)); 
        new->left = new->right = NULL; 
        new->value = num; 
        if (root == NULL) 
            root = new; 
        else 
        { 
            insert(new, root); 
        } 
    }
    printf("elements in a tree in inorder are\n"); 
    queue[++rear] = root->value;
    bfs_traverse(root);
    for (i = 0;i <= rear;i++)
        printf("%d -> ", queue[i]);
    printf("%d\n", root->right->right->right->value);
}
 
/* inserting nodes of a tree */
void insert(node * new , node *root) 
{ 
    if (new->value>root->value) 
    {     
        if (root->right == NULL) 
            root->right = new; 
        else 
            insert (new, root->right); 
    } 
    if (new->value < root->value) 
    {     
        if (root->left  ==  NULL) 
            root->left = new; 
        else 
            insert (new, root->left); 
    }     
}
 
/* displaying elements using BFS traversal */
void bfs_traverse(node *root)
{
    val = root->value;
    if ((front <= rear)&&(root->value == queue[front]))
    {
        if (root->left != NULL)
            queue[++rear] = root->left->value;
        if (root->right != NULL || root->right  ==  NULL)
            queue[++rear] = root->right->value;
        front++;
    }
    if (root->left != NULL)
    {
        bfs_traverse(root->left);
    }
    if (root->right != NULL)
    {
        bfs_traverse(root->right);
    }
}



6. C Examples on Inorder Traversal of a Binary Tree

* C Program to Search for a Particular Value in a Binary Tree
 *                  50
 *                  /\
 *                20  30
 *                /\                               
 *              70 80
 *              /\   \
 *            10 40  60
 */
 
#include <stdio.h>
#include <malloc.h>
/* Structure to create the binary tree */
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
 
struct btnode *root = NULL;
int flag;
 
/* Function Prototypes */
void in_order_traversal(struct btnode *);
void in_order_search(struct btnode *,int);
struct btnode *newnode(int);
 
void main()
{ 
    /* Inserting elements in the binary tree */
    int search_val;
    root = newnode(50);
    root->l = newnode(20);
    root->r = newnode(30);
    root->l->l = newnode(70);
    root->l->r = newnode(80);
    root->l->l->l = newnode(10);
    root->l->l->r = newnode(40);
    root->l->r->r = newnode(60);
 
    printf("The elements of Binary tree are:");
    in_order_traversal(root);
    printf("Enter the value to be searched:");
    scanf("%d", &search_val);
    in_order_search(root, search_val);
    if (flag  =  =  0)    // flag to check if the element is present in the tree or not
    {
        printf("Element not present in the binary tree\n");
    }
}
 
/* Code to dynamically create new nodes */
struct btnode* newnode(int value)
{
    struct btnode *temp = (struct btnode *)malloc(sizeof(struct btnode));
    temp->value = value;
    temp->l = NULL;
    temp->r = NULL;
    return temp;
}
 
/* Code to display the elements of the binary tree */
 
void in_order_traversal(struct btnode *p)
{
    if (!p)
    {
        return;
    }
    in_order_traversal(p->l);
    printf("%d->", p->value);
    in_order_traversal(p->r);
}
 
/* Code to search for a particular element in the tree */
void in_order_search(struct btnode *p, int val)
{
    if (!p)
    {
        return;
    }
    in_order_search(p->l, val);
    if(p->value == val)
    {
        printf("\nElement present in the binary tree.\n");
        flag = 1;
    }
    in_order_search(p->r, val);
}


* C Program to Find the Sum of All Nodes in a Binary Tree
 *                          50
 *                          /\
 *                         20 30
 *                         /\                               
 *                        70 80
 *                        /\   \
 *                      10 40  60
 */
#include <stdio.h>
#include <malloc.h>
 
/* Structure to create the binary tree */
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
};
struct btnode *root = NULL;
int sum;
 
/* Function Prototypes */
 
void in_order_traversal(struct btnode *);
void in_order_sum(struct btnode *);
struct btnode *newnode(int);
 
void main()
{ 
 
    /* Inserting elements in the binary tree */
    root = newnode(50);
    root->l = newnode(20);
    root->r = newnode(30);
    root->l->l = newnode(70);
    root->l->r = newnode(80);
    root->l->l->l = newnode(10);
    root->l->l->r = newnode(40);
    root->l->r->r = newnode(60);
    printf("The elements of Binary tree are:");
    in_order_traversal(root);
    in_order_sum(root);
    printf("\nThe sum of all the elements are:%d", sum);
}
 
/* Code to dynamically create new nodes */
struct btnode* newnode(int value)
{
    struct btnode *temp = (struct btnode *)malloc(sizeof(struct btnode));
    temp->value = value;
    temp->l = NULL;
    temp->r = NULL;
    return temp;
}
 
/* Code to display the elements of the binary tree */
void in_order_traversal(struct btnode *p)
{
    if (!p)
    {
        return;
    }
    in_order_traversal(p->l);
    printf("%d->",  p->value);
    in_order_traversal(p->r);
}
 
/* Code to find the sum of all elements in the tree */
void in_order_sum(struct btnode *p)
{
    if (!p)
    {
        return;
    }
    in_order_sum(p->l);
    sum = sum + p->value;
    in_order_sum(p->r);
}



/* 
 * C Program to Construct a Binary Search Tree and perform deletion, inorder traversal on it
 */ 
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *l;
    struct btnode *r;
}*root = NULL, *temp = NULL, *t2, *t1;
 
void delete1();
void insert();
void delete();
void inorder(struct btnode *t);
void create();
void search(struct btnode *t);
void preorder(struct btnode *t);
void postorder(struct btnode *t);
void search1(struct btnode *t,int data);
int smallest(struct btnode *t);
int largest(struct btnode *t);
 
int flag = 1;
 
void main()
{
    int ch;
 
    printf("\nOPERATIONS ---");
    printf("\n1 - Insert an element into tree\n");
    printf("2 - Delete an element from the tree\n");
    printf("3 - Inorder Traversal\n");
    printf("4 - Preorder Traversal\n");
    printf("5 - Postorder Traversal\n");
    printf("6 - Exit\n");
    while(1)
    {
        printf("\nEnter your choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:    
            insert();
            break;
        case 2:    
            delete();
            break;
        case 3:    
            inorder(root);
            break;
        case 4:    
            preorder(root);
            break;
        case 5:    
            postorder(root);
            break;
        case 6:    
            exit(0);
        default :     
            printf("Wrong choice, Please enter correct choice  ");
            break;    
        }
    }
}
 
/* To insert a node in the tree */
void insert()
{
    create();
    if (root == NULL) 
        root = temp;
    else    
        search(root);    
}
 
/* To create a node */
void create()
{
    int data;
 
    printf("Enter data of node to be inserted : ");
    scanf("%d", &data);
    temp = (struct btnode *)malloc(1*sizeof(struct btnode));
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* Function to search the appropriate position to insert the new node */
void search(struct btnode *t)
{
    if ((temp->value > t->value) && (t->r != NULL))      /* value more than root node value insert at right */
        search(t->r);
    else if ((temp->value > t->value) && (t->r == NULL))
        t->r = temp;
    else if ((temp->value < t->value) && (t->l != NULL))    /* value less than root node value insert at left */
        search(t->l);
    else if ((temp->value < t->value) && (t->l == NULL))
        t->l = temp;
}
 
/* recursive function to perform inorder traversal of tree */
void inorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display");
        return;
    }
    if (t->l != NULL)    
        inorder(t->l);
    printf("%d -> ", t->value);
    if (t->r != NULL)    
        inorder(t->r);
}
 
/* To check for the deleted node */
void delete()
{
    int data;
 
    if (root == NULL)
    {
        printf("No elements in a tree to delete");
        return;
    }
    printf("Enter the data to be deleted : ");
    scanf("%d", &data);
    t1 = root;
    t2 = root;
    search1(root, data);
}
 
/* To find the preorder traversal */
void preorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display");
        return;
    }
    printf("%d -> ", t->value);
    if (t->l != NULL)    
        preorder(t->l);
    if (t->r != NULL)    
        preorder(t->r);
}
 
/* To find the postorder traversal */
void postorder(struct btnode *t)
{
    if (root == NULL)
    {
        printf("No elements in a tree to display ");
        return;
    }
    if (t->l != NULL) 
        postorder(t->l);
    if (t->r != NULL) 
        postorder(t->r);
    printf("%d -> ", t->value);
}
 
/* Search for the appropriate position to insert the new node */
void search1(struct btnode *t, int data)
{
    if ((data>t->value))
    {
        t1 = t;
        search1(t->r, data);
    }
    else if ((data < t->value))
    {
        t1 = t;
        search1(t->l, data);
    }
    else if ((data==t->value))
    {
        delete1(t);
    }
}
 
/* To delete a node */
void delete1(struct btnode *t)
{
    int k;
 
    /* To delete leaf node */
    if ((t->l == NULL) && (t->r == NULL))
    {
        if (t1->l == t)
        {
            t1->l = NULL;
        }
        else
        {
            t1->r = NULL;
        }
        t = NULL;
        free(t);
        return;
    }
 
    /* To delete node having one left hand child */
    else if ((t->r == NULL))
    {
        if (t1 == t)
        {
            root = t->l;
            t1 = root;
        }
        else if (t1->l == t)
        {
            t1->l = t->l;
 
        }
        else
        {
            t1->r = t->l;
        }
        t = NULL;
        free(t);
        return;
    }
 
    /* To delete node having right hand child */
    else if (t->l == NULL)
    {
        if (t1 == t)
        {
            root = t->r;
            t1 = root;
        }
        else if (t1->r == t)
            t1->r = t->r;
        else
            t1->l = t->r;
        t == NULL;
        free(t);
        return;
    }
 
    /* To delete node having two child */
    else if ((t->l != NULL) && (t->r != NULL))  
    {
        t2 = root;
        if (t->r != NULL)
        {
            k = smallest(t->r);
            flag = 1;
        }
        else
        {
            k =largest(t->l);
            flag = 2;
        }
        search1(root, k);
        t->value = k;
    }
 
}
 
/* To find the smallest element in the right sub tree */
int smallest(struct btnode *t)
{
    t2 = t;
    if (t->l != NULL)
    {
        t2 = t;
        return(smallest(t->l));
    }
    else    
        return (t->value);
}
 
/* To find the largest element in the left sub tree */
int largest(struct btnode *t)
{
    if (t->r != NULL)
    {
        t2 = t;
        return(largest(t->r));
    }
    else    
        return(t->value);
}


 * C Program to Count Number of Leaf Nodes in a Tree 
 
       50
      /  \
     20   30
    /  \    
   70  80
  /  \    \
 10     40     60    
(50,20,30,70,80,10,40,60)
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode {
    int value;
    struct btnode * l;
    struct btnode * r;
};
 
typedef struct btnode bt;
 
bt *root;
bt *new, *list;
int count = 0;
 
bt * create_node();
void display(bt *);
void construct_tree();
void count_leaf(bt *);
 
void main()
{
    construct_tree();
    display(root);
    count_leaf(root);
    printf("\n leaf nodes are : %d",count);
}
 
/* To create a empty node */
bt * create_node()
{
    new = (bt *)malloc(sizeof(bt));
    new->l = NULL;
    new->r = NULL;
}
 
/* To construct a tree */
void construct_tree()
{
    root = create_node();
    root->value = 50;
    root->l = create_node();
    root->l->value = 20;
    root->r = create_node();
    root->r->value = 30;
    root->l->l = create_node();
    root->l->l->value = 70;
    root->l->r = create_node();
    root->l->r->value = 80;
    root->l->r->r = create_node();
    root->l->r->r->value = 60;
    root->l->l->l = create_node();
    root->l->l->l->value = 10;
    root->l->l->r = create_node();
    root->l->l->r->value = 40; 
}
 
/* To display the elements in a tree using inorder */
void display(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    display(list->l);
    printf("->%d", list->value);
    display(list->r);
}
 
/* To count the number of leaf nodes */
void count_leaf(bt * list)
{
    if (list == NULL)
    {
        return;
    }
    if (list->l == NULL && list->r == NULL)
    {
        count++;
    }
    count_leaf(list->l);
    count_leaf(list->r);
}



/* 
 * C Program to Find Nodes which are at Maximum Distance in Binary Tree
 */
#include <stdio.h>
#include <stdlib.h>
 
struct btnode
{
    int value;
    struct btnode *r,*l;
} *root = NULL, *temp = NULL;
 
void create();
void insert();
void add(struct btnode *t);
void maxdistance(struct btnode *t);
 
int count = 0, max = 0, v[100] = {0}, z = 0, max2, max1[100] = {0};
 
void main()
{
    int ch, i;
 
    printf("Program to find nodes at maximum distance");
    printf("\n  OPERATIONS ----"); 
    printf("\n1] Insert ");
    printf("\n2] Display nodes ");
    printf("\n3] Exit ");    
    while (1)
    {                        
        printf("\nEnter your choice : ");
        scanf("%d", &ch);
        switch (ch)
        {
        case 1:    
            insert();
            break;
        case 2:    
            max = 0;
            count = 0;
            maxdistance(root);
        for (i = 1; i < z; i++)
        {
            max2 = max1[0];
            if (max2 < max1[i])
                max2 = max1[i];
        }
        printf("Maximum distance nodes \nNodes\t Distance "); 
        for (i = 0; i < z; i++)
        {
            if (max2 == max1[i])
                printf("\n %d\t  %d ",v[i],max2);        
        }
        break;
        case 3: 
            exit(0);
        default :     
            printf("Wrong choice, Please enter correct choice  ");
            break;    
        }
    }
}
 
/* To create a new node with the data from the user */
void create()
{
    int data;
 
    printf("Enter the data of node : ");
    scanf("%d", &data);
    temp = (struct btnode* ) malloc(1*(sizeof(struct btnode)));
    temp->value = data;
    temp->l = temp->r = NULL;
}
 
/* To check for root node and then create it */
void insert()
{
    create();
 
    if (root == NULL)
        root = temp;
    else
        add(root);
}
 
/* Search for the appropriate position to insert the new node */
void add(struct btnode *t)
{
    if ((temp->value > t->value) && (t->r!=NULL))    /* value more than root node value insert at right */
        add(t->r);
    else if ((temp->value > t->value) && (t->r==NULL))
        t->r = temp;
    else if ((temp->value < t->value) && (t->l!=NULL))   /* value less than root node value insert at left */
        add(t->l);
    else if ((temp->value < t->value) && (t->l==NULL))
        t->l = temp;
}
 
/* Function to find the max distance nodes */
void maxdistance(struct btnode *t)
{
    if (t->l!=NULL)
    {
        count++;            /* to count the number of nodes in between root and leaf */
        maxdistance(t->l);
    }
    if (max < count)
        max = count;
    if (max == count)
    {
        max1[z] = max;
        v[z] = t->value;
        z++;
    }
    if (t->r != NULL)
    {
        count++;        
        maxdistance(t->r);
    }
    count--;
}




INDEX:
1.tree from inorder to preorder(1)
2.tree from inorder and postorder (7)
3.binary tree (14)
4. Recursive operations in Binary Search Tree(25)
5. Non recursive operations in Binary Search Tree(33)


1. Program to construct a binary tree from inorder and preorder
#include<stdio.h>
#include<stdlib.h>

struct treenode
{
	int info;
	struct treenode *lchild;
	struct treenode *rchild;
}*root=NULL;

struct listnode
{
	struct listnode *prev;
	int info;
	struct listnode *next;
}*pre=NULL, *in=NULL;

void display(struct treenode *ptr,int level);
struct listnode *addtoempty(struct listnode *start,int data);
struct listnode *addatend(struct listnode *start,int data);
struct listnode *create_list(struct listnode *start, int n);
struct treenode *construct(struct listnode *inptr,struct listnode *preptr, int num);
void inorder(struct treenode *ptr);
void postorder(struct treenode *ptr);
void preorder(struct treenode *ptr);

main( )
{
	int n;
	
	printf("Enter the number of nodes  :  ");
	scanf("%d",&n);

	printf("Enter inorder\n");
	in = create_list(in, n);

	printf("Enter preorder\n");
	pre=create_list(pre, n);

	root = construct(in,pre,n);

	printf("Inorder : ");  inorder(root);
	printf("\nPostorder : ");  postorder(root);
	printf("\nPreorder : "); preorder(root);
	printf("\n\nTree is : \n");
	display(root,0);
	printf("\n");
}

struct treenode *construct(struct listnode *inptr,struct listnode *preptr, int num )
{
	struct treenode *temp;
	struct listnode *q;

	int i,j;
	if(num==0)
		return NULL;
	
	temp=(struct treenode *)malloc(sizeof(struct treenode));
	temp->info=preptr->info;
	temp->lchild = NULL;
	temp->rchild = NULL;

	if(num==1)/*if only one node in tree */
		return temp;
	
	q = inptr;	
	for(i=0; q->info != preptr->info; i++)
		q = q->next;
	
	/*Now q points to root node in inorder list and 
	 and number of nodes in its left subtree is i*/
	 
	/*For left subtree*/
	temp->lchild = construct(inptr, preptr->next, i);
	
	/*For right subtree*/
	for(j=1;j<=i+1;j++)
		preptr=preptr->next;
	temp->rchild = construct(q->next, preptr, num-i-1);
	 
	return temp;
}/*End of construct()*/

void display(struct treenode *ptr,int level)
{
	int i;
	if ( ptr!=NULL )
	{
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/

struct listnode *create_list(struct listnode *start, int n)
{
	int i, data;
	start=NULL;
	for(i=1;i<=n;i++)
	{
		printf("Enter the element to be inserted : ");
		scanf("%d",&data);
		if(start==NULL)
			start=addtoempty(start,data);
		else
			start=addatend(start,data);	
	}
	return start;
}/*End of create_list()*/

struct listnode *addtoempty(struct listnode *start,int data)
{
	struct listnode *tmp;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	tmp->prev=NULL;
	tmp->next=NULL;
	start=tmp;
	return start;
}/*End of addtoempty( )*/
struct listnode *addatend(struct listnode *start,int data)
{
	struct listnode *tmp,*p;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	p=start;
	while(p->next!=NULL)
		p=p->next;
	p->next=tmp;
	tmp->next=NULL;
	tmp->prev=p;
	return start;
}/*End of addatend( )*/

void inorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/
void postorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

void preorder(struct treenode *ptr)
{
	if(root==NULL)
	{printf("Tree is empty");
		return;}
	if(ptr!=NULL)
	{printf("%d  ",ptr->info);
preorder(ptr->lchild);
		preorder(ptr->rchild);
	}}/*End of preorder( )*/


2 .Program for constructing a binary tree from inorder and postorder 

#include<stdio.h>
#include<stdlib.h>

struct treenode
{
	int info;
	struct treenode *lchild;
	struct treenode *rchild;
}*root=NULL;

struct listnode
{
	struct listnode *prev;
	int info;
	struct listnode *next;
}*post=NULL, *in=NULL;

void display(struct treenode *ptr,int level);
struct listnode *addtoempty(struct listnode *start,int data);
struct listnode *addatend(struct listnode *start,int data);
struct listnode *create_list(struct listnode *start, int n);
struct treenode *construct(struct listnode *inptr,struct listnode *postptr, int num);
void inorder(struct treenode *ptr);
void preorder(struct treenode *ptr);
void postorder(struct treenode *ptr);

main()
{
	int n;

	printf("Enter the number of nodes  :  ");
	scanf("%d",&n);

	printf("Enter inorder\n");
	in = create_list(in,n);

	printf("Enter postorder\n");
	post = create_list(post,n);

	root = construct(in,post,n);

	printf("Inorder : ");  inorder(root);
	printf("\nPostorder : ");  postorder(root);
	printf("\nPreorder : "); preorder(root);
	printf("\n\nTree is : \n");
	display(root,0);
	printf("\n");
}/*End of main()*/

struct treenode *construct(struct listnode *inptr,struct listnode *postptr, int num)
{
	struct treenode *temp;
	struct listnode *q, *ptr;

	int i,j;
	if(num==0)
		return NULL;
	
	ptr=postptr;
	for(i=1;i<num;i++)
		ptr = ptr->next;

	/*Now ptr points to last node of postorder which is root*/
	
	temp=(struct treenode *)malloc(sizeof(struct treenode));
	temp->info=ptr->info;
	temp->lchild = NULL;
	temp->rchild = NULL;

	if(num==1)/*if only one node in tree */
		return temp;
		
	q=inptr;
	for(i=0; q->info!=ptr->info; i++ )
		q = q->next;

	/*Now i denotes the number of nodes in left subtree
	and q points to root node in inorder list*/	
	
	/*For left subtree*/
	temp->lchild = construct(inptr, postptr, i);
			
	/*For right subtree*/
	for(j=1;j<=i;j++)
		postptr = postptr->next;
	temp->rchild = construct(q->next, postptr, num-i-1);
		
	return temp;
}/*End of construct()*/

struct listnode *create_list(struct listnode *start, int n)
{
	int i,data;
	start=NULL;
	for(i=1;i<=n;i++)
	{
		printf("Enter the element to be inserted : ");
		scanf("%d",&data);
		if(start==NULL)
			start=addtoempty(start,data);
		else
			start=addatend(start,data);	
	}
	return start;
}/*End of create_list()*/

struct listnode *addtoempty(struct listnode *start,int data)
{
	struct listnode *tmp;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	tmp->prev=NULL;
	tmp->next=NULL;
	start=tmp;
	return start;
}/*End of addtoempty( )*/

struct listnode *addatend(struct listnode *start,int data)
{
	struct listnode *tmp,*p;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	p=start;
	while(p->next!=NULL)
		p=p->next;
	p->next=tmp;
	tmp->next=NULL;
	tmp->prev=p;
	return start;
}/*End of addatend( )*/

void inorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/
void postorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

void preorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		printf("%d  ",ptr->info);
		preorder(ptr->lchild);
		preorder(ptr->rchild);
	}
}/*End of preorder( )*/

void display(struct treenode *ptr,int level)
{
	int i;
	if(ptr!=NULL)
	{
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/


















3.Binary tree
/*Recursive operations in Binary Search Tree*/
/*display() function displays the tree from left to right instead of top to bottom
root is displayed at the leftmost position*/

#include<stdio.h>
#include<stdlib.h>
#define STOP getchar()

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search(struct node *ptr, int skey);
struct node *insert(struct node *ptr, int ikey);
struct node *del(struct node *ptr, int dkey);

int height(struct node *ptr);
struct node *minimum(struct node *ptr);
struct node *maximum(struct node *ptr);
void preorder(struct node *ptr);
void inorder(struct node *ptr);
void postorder(struct node *ptr);
int height(struct node *ptr);
void display(struct node *ptr,int level);

main( )
{
	struct node *root=NULL,*ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Height of tree\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		printf("\nTree is -->\n.......................\n\n");
		display(root,0);
		printf("\n\n.......................\n\n");

		switch(choice)
		{
		case 1: 
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search(root, k);
			if(ptr==NULL)
				printf("Key not present\n");
			else
				printf("Key present\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			printf("\nInserting %d\n\n",k);
			root = insert(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del(root,k);
			break;
		 case 4:
			preorder(root);
			break;
		 case 5:
			inorder(root);
			break;
		 case 6:
			postorder(root);
			break;
		 case 7:
			 printf("Height of tree is %d\n", height(root));
			 break;
		 case 8:
			ptr = minimum(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = maximum(root); 	
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		 case 9:
			exit(1);
		 default:
			printf("Wrong choice\n");
		}/*End of switch */
	}/*End of while */
}/*End of main( )*/

struct node *search(struct node *ptr, int skey)
{
	
	if(ptr!=NULL)
		printf("search() fn called for ptr = Address of %d\n", ptr->info);
	STOP;
	
	if(ptr==NULL)	
	{	
		printf("search() fn called for ptr = NULL\n");
		printf("Base Case 1 Reached, Recursion stops\n");
		printf("key %d is not found in the tree\n", skey);
		return NULL;
	}
	else if(skey < ptr->info)/*search in left subtree*/	
	{
		printf("Search in left subtree of %d\n",ptr->info);
		return search(ptr->lchild, skey);	
	}
	else if(skey > ptr->info)/*search in right subtree*/
	{
		printf("Search in left subtree of %d\n",ptr->info);
		return search(ptr->rchild, skey);
	}

	else 
	{
		printf("Base Case 2 Reached, Recursion stops\n");
		printf("key %d found in the tree\n", skey);
		return ptr;
	}

}

struct node *insert(struct node *ptr, int ikey )
{
	
	if(ptr!=NULL)
		printf("insert() fn called for ptr = Address of %d\n", ptr->info);
	STOP;
	if(ptr==NULL)	
	{
		printf("insert() fn called for ptr = NULL \n");
		printf("Base Case 1 Reached, Recursion stops\n");
		printf("key %d is not in the tree and so it can be inserted\n", ikey);
		ptr = (struct node *) malloc(sizeof(struct node));
		ptr->info = ikey;
		ptr->lchild = NULL;
		ptr->rchild = NULL;
		printf("Now ptr points to %d\n",ptr->info); 
		STOP;
		printf("Unwinding phase begins and all recursive calls are returned\n");
	}
	else if(ikey < ptr->info)	/*Insertion in left subtree*/
	{	
		printf("Insertion to be done in left subtree of %d\n",ptr->info);
		ptr->lchild = insert(ptr->lchild, ikey);
		printf("ptr points to %d and its left child is assigned address of %d\n",ptr->info, ptr->lchild->info);
	}
	else if(ikey > ptr->info)				/*Insertion in right subtree */
	{
		printf("Insertion to be done in right subtree of %d\n",ptr->info);
		ptr->rchild = insert(ptr->rchild, ikey);  
		printf("ptr points to %d and its right child is assigned address of %d\n", ptr->info, ptr->rchild->info);
	}
	else
	{
		printf("Base Case 2 Reached, Recursion stops");
        printf("\nkey %d is already present, can't be inserted\n",ikey);
		STOP;
		printf("Unwinding phase begins and all recursive calls are returned\n");
	}
	STOP;
	printf("Returning address of %d\n\n", ptr->info);
	return(ptr);
}/*End of insert( )*/

struct node *del(struct node *ptr, int dkey)
{
	struct node *tmp, *succ;

	if( ptr == NULL)
	{
		printf("dkey not found\n");
		return(ptr);
	}
	if( dkey < ptr->info )/*delete from left subtree*/
		ptr->lchild = del(ptr->lchild, dkey);
	else if( dkey > ptr->info )/*delete from right subtree*/
		ptr->rchild = del(ptr->rchild, dkey);
	else
	{
		/*Node to be deleted is found*/
		if( ptr->lchild!=NULL  &&  ptr->rchild!=NULL )  /*2 children*/
		{
			succ=ptr->rchild;
			while(succ->lchild)
				succ=succ->lchild;
			ptr->info=succ->info;
			ptr->rchild = del(ptr->rchild, succ->info);
		}
		else	
		{
			tmp = ptr;
			if( ptr->lchild != NULL ) /*only left child*/
				ptr = ptr->lchild;
			else if( ptr->rchild != NULL) /*only right child*/
				ptr = ptr->rchild;
			else	/* no child */
				ptr = NULL;
			free(tmp);
		}						
	}
	return ptr; 
}/*End of del( )*/

struct node *minimum(struct node *ptr)
{
	if(ptr==NULL)
		return NULL;
	else if(ptr->lchild==NULL)
        return ptr;
	else 
		return minimum(ptr->lchild);
}/*End of minimum()*/

struct node *maximum(struct node *ptr)
{
	if(ptr==NULL)	
		return NULL;
	else if(ptr->rchild==NULL)
        return ptr;
	else 
		return maximum(ptr->rchild);
}/*End of maximum()*/

void preorder(struct node *ptr)
{
	if(ptr == NULL )	/*Base Case*/
		return;
	else
	{
		printf("%d  ",ptr->info);
		preorder(ptr->lchild);
		preorder(ptr->rchild);
	}
}/*End of preorder( )*/

void inorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	else
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/

void postorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	else
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

int height(struct node *ptr)
{
	int h_left, h_right; 

	if (ptr == NULL) /*Base Case*/
		return 0; 
	
	h_left =  height(ptr->lchild); 
	printf("Height of left subtree of %d is %d\n", ptr->info, h_left);
	
	h_right = height(ptr->rchild); 
	printf("Height of right subtree of %d is %d\n", ptr->info, h_right);
	
	if (h_left > h_right) 
	{
		printf("Height of tree %d is %d\n", ptr->info, 1 + h_left);
		return 1 + h_left; 
	}
	else 
	{
		printf("Height of subtree %d is %d\n", ptr->info, 1 + h_right);
		return 1 + h_right; 
	}
}/*End of height()*/

void display(struct node *ptr,int level)
{
	int i;
	if(ptr == NULL )/*Base Case*/
		return;
	else
    {
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/



















4. Recursive operations in Binary Search Tree
#include<stdio.h>
#include<stdlib.h>

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search(struct node *ptr, int skey);
struct node *insert(struct node *ptr, int ikey);
struct node *del(struct node *ptr, int dkey);
struct node *Min(struct node *ptr);
struct node *Max(struct node *ptr);
int height(struct node *ptr);
void preorder(struct node *ptr);
void inorder(struct node *ptr);
void postorder(struct node *ptr);

main( )
{
	struct node *root=NULL,*ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Height of tree\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		switch(choice)
		{
		case 1: 
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search(root, k);
			if(ptr!=NULL)
				printf("Key found\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			root = insert(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del(root,k);
			break;
		 case 4:
			preorder(root);
			break;
		 case 5:
			inorder(root);
			break;
		 case 6:
			postorder(root);
			break;
		 case 7:
			 printf("Height of tree is %d\n", height(root));
			 break;
		 case 8:
			ptr = Min(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = Max(root); 	
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		 case 9:
			exit(1);
		 default:
			printf("Wrong choice\n");
		}/*End of switch */
	}/*End of while */
}/*End of main( )*/

struct node *search(struct node *ptr, int skey)
{
	if(ptr==NULL)   
	{	
		printf("key not found\n");
		return NULL;
	}
	else if(skey < ptr->info)/*search in left subtree*/	
		return search(ptr->lchild, skey);	
	else if(skey > ptr->info)/*search in right subtree*/
		return search(ptr->rchild, skey);
	else /*skey found*/
		return ptr;
}/*End of search()*/

struct node *insert(struct node *ptr, int ikey )
{
	if(ptr==NULL)	
	{
		ptr = (struct node *) malloc(sizeof(struct node));
		ptr->info = ikey;
		ptr->lchild = NULL;
		ptr->rchild = NULL;
	}
	else if(ikey < ptr->info)	/*Insertion in left subtree*/
		ptr->lchild = insert(ptr->lchild, ikey);
	else if(ikey > ptr->info)	/*Insertion in right subtree */
		ptr->rchild = insert(ptr->rchild, ikey);  
	else
		printf("Duplicate key\n");
	return ptr;
}/*End of insert( )*/

struct node *del(struct node *ptr, int dkey)
{
	struct node *tmp, *succ;

	if( ptr == NULL)
	{
		printf("dkey not found\n");
		return(ptr);
	}
	if( dkey < ptr->info )/*delete from left subtree*/
		ptr->lchild = del(ptr->lchild, dkey);
	else if( dkey > ptr->info )/*delete from right subtree*/
		ptr->rchild = del(ptr->rchild, dkey);
	else
	{
		/*key to be deleted is found*/
		if( ptr->lchild!=NULL  &&  ptr->rchild!=NULL )  /*2 children*/
		{
			succ=ptr->rchild;
			while(succ->lchild)
				succ=succ->lchild;
			ptr->info=succ->info;
			ptr->rchild = del(ptr->rchild, succ->info);
		}
		else	
		{
			tmp = ptr;
			if( ptr->lchild != NULL ) /*only left child*/
				ptr = ptr->lchild;
			else if( ptr->rchild != NULL) /*only right child*/
				ptr = ptr->rchild;
			else	/* no child */
				ptr = NULL;
			free(tmp);
		}						
	}
	return ptr; 
}/*End of del( )*/

struct node *Min(struct node *ptr)
{
	if(ptr==NULL)
		return NULL;
	else if(ptr->lchild==NULL)
        return ptr;
	else 
		return Min(ptr->lchild);
}/*End of min()*/

struct node *Max(struct node *ptr)
{
	if(ptr==NULL) 
		return NULL;
	else if(ptr->rchild==NULL)
        return ptr;
	else 
		return Max(ptr->rchild);
}/*End of max()*/

void preorder(struct node *ptr)
{
	if(ptr == NULL )	/*Base Case*/
		return;
	printf("%d  ",ptr->info);
	preorder(ptr->lchild);
	preorder(ptr->rchild);
}/*End of preorder( )*/

void inorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	inorder(ptr->lchild);
	printf("%d  ",ptr->info);
	inorder(ptr->rchild);
}/*End of inorder( )*/

void postorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	postorder(ptr->lchild);
	postorder(ptr->rchild);
	printf("%d  ",ptr->info);
	
}/*End of postorder( )*/

int height(struct node *ptr)
{
	int h_left, h_right; 

	if (ptr == NULL) /*Base Case*/
		return 0; 

	h_left =  height(ptr->lchild); 
	h_right = height(ptr->rchild); 

	if (h_left > h_right) 
		return 1 + h_left; 
	else 
		return 1 + h_right; 
}/*End of height()*/




















5. Non recursive operations in Binary Search Tree

#include<stdio.h>
#include<stdlib.h>
#define MAX 50

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search_nrec(struct node *root, int skey);
struct node *min_nrec(struct node *root);
struct node *max_nrec(struct node *root);
struct node *insert_nrec(struct node *root, int ikey );
struct node *del_nrec(struct node *root, int dkey);
struct node *case_c(struct node *root, struct node *par,struct node *ptr);
struct node *case_b(struct node *root,struct node *par,struct node *ptr);
struct node *case_a(struct node *root, struct node *par,struct node *ptr );
struct node *del_nrec1(struct node *root, int item);
void nrec_pre(struct node *root);
void nrec_in(struct node *root);
void nrec_post(struct node *root);
void level_trav(struct node *root);


struct node *queue[MAX];
int front=-1,rear=-1;
void insert_queue(struct node *item);
struct node *del_queue();
int queue_empty();

struct node *stack[MAX];
int top=-1;
void push_stack(struct node *item);
struct node *pop_stack();
int stack_empty();

main( )
{
	struct node *root=NULL, *ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Level order traversal\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		switch(choice)
		{
		case 1:
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search_nrec(root, k);
			if(ptr==NULL)
				printf("Key not present\n");
			else
				printf("Key present\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			root = insert_nrec(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del_nrec(root, k);
			break;
		case 4:
			nrec_pre(root);
			break;
		case 5:
			nrec_in(root);
			break;
		case 6:
			nrec_post(root);
			break;
		case 7:
			level_trav(root);
			break;
		case 8:
			ptr = min_nrec(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = max_nrec(root);
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		case 9:
			exit(1);
		default:
			printf("Wrong choice\n");
		}/*End of switch*/
	}/*End of while */
}/*End of main( )*/

struct node *search_nrec(struct node *ptr, int skey)
{
	while(ptr!=NULL)
	{
		if(skey < ptr->info)
			ptr = ptr->lchild; /*Move to left child*/
		else if(skey > ptr->info)
			ptr = ptr->rchild;  /*Move to right child */
		else	/*skey found*/
			return ptr;
	}
	return NULL;
}/*End of search_nrec()*/

struct node *insert_nrec(struct node *root, int ikey)
{
	struct node *tmp,*par,*ptr;

	ptr = root;
	par = NULL;

	while( ptr!=NULL)
	{
		par = ptr;
		if(ikey < ptr->info)
			ptr = ptr->lchild;
		else if( ikey > ptr->info )
			ptr = ptr->rchild;
		else
		{
			printf("Duplicate key");
			return root;
		}
	}

	tmp=(struct node *)malloc(sizeof(struct node));
	tmp->info=ikey;
	tmp->lchild=NULL;
	tmp->rchild=NULL;

	if(par==NULL)
		root=tmp;
	else if( ikey < par->info )
		par->lchild=tmp;
	else
		par->rchild=tmp;

	return root;
}/*End of insert_nrec( )*/

struct node *del_nrec1(struct node *root, int dkey)
{
	struct node *par,*ptr, *child, *succ, *parsucc;

	ptr = root;
	par = NULL;
	while( ptr!=NULL)
	{
		if( dkey == ptr->info)
			break;
		par = ptr;
		if(dkey < ptr->info)
			ptr = ptr->lchild;
		else
			ptr = ptr->rchild;
	}

	if(ptr==NULL)
	{
		printf("dkey not present in tree");
		return root;
	}

	/*Case C: 2 children*/
	if(ptr->lchild!=NULL && ptr->rchild!=NULL)
	{
		parsucc = ptr;
		succ = ptr->rchild;
		while(succ->lchild!=NULL)
		{
			parsucc = succ;
			succ = succ->lchild;
		}
		ptr->info = succ->info;
		ptr = succ;
		par = parsucc;
	}

	/*Case B and Case A : 1 or no child*/
	if(ptr->lchild!=NULL) /*node to be deleted has left child */
		child=ptr->lchild;
	else                /*node to be deleted has right child */
		child=ptr->rchild;

	if(par==NULL )   /*node to be deleted is root node*/
		root=child;
	else if( ptr==par->lchild)/*node is left child of its parent*/
		par->lchild=child;
	else       /*node is right child of its parent*/
		par->rchild=child;
	free(ptr);
	return root;
}

struct node *del_nrec(struct node *root, int dkey)
{
	struct node *par,*ptr;

	ptr = root;
	par = NULL;
	while(ptr!=NULL)
	{
		if( dkey == ptr->info)
			break;
		par = ptr;
		if(dkey < ptr->info)
			ptr = ptr->lchild;
		else
			ptr = ptr->rchild;
	}

	if(ptr==NULL)
		printf("dkey not present in tree\n");
	else if(ptr->lchild!=NULL && ptr->rchild!=NULL)/*2 children*/
		root = case_c(root,par,ptr);
	else if(ptr->lchild!=NULL )/*only left child*/
        root = case_b(root, par,ptr);
	else if(ptr->rchild!=NULL)/*only right child*/
        root = case_b(root, par,ptr);
	else /*no child*/
		root = case_a(root,par,ptr);

	return root;
}/*End of del_nrec( )*/

struct node *case_a(struct node *root, struct node *par,struct node *ptr )
{
	if(par==NULL) /*root node to be deleted*/
		root=NULL;
	else if(ptr==par->lchild)
		par->lchild=NULL;
	else
		par->rchild=NULL;
	free(ptr);
	return root;
}/*End of case_a( )*/

struct node *case_b(struct node *root,struct node *par,struct node *ptr)
{
	struct node *child;

	/*Initialize child*/
	if(ptr->lchild!=NULL) /*node to be deleted has left child */
		child=ptr->lchild;
	else                /*node to be deleted has right child */
		child=ptr->rchild;

	if(par==NULL )   /*node to be deleted is root node*/
		root=child;
	else if( ptr==par->lchild)   /*node is left child of its parent*/
		par->lchild=child;
	else                  /*node is right child of its parent*/
		par->rchild=child;
	free(ptr);
	return root;
}/*End of case_b( )*/

struct node *case_c(struct node *root, struct node *par,struct node *ptr)
{
	struct node *succ,*parsucc;

	/*Find inorder successor and its parent*/
	parsucc = ptr;
	succ = ptr->rchild;
	while(succ->lchild!=NULL)
	{
		parsucc = succ;
		succ = succ->lchild;
	}

	ptr->info = succ->info;

	if(succ->lchild==NULL && succ->rchild==NULL)
		root = case_a(root, parsucc,succ);
	else
		root = case_b(root, parsucc,succ);
	return root;
}/*End of case_c( )*/

struct node *min_nrec(struct node *ptr)
{
	if(ptr!=NULL)
		while(ptr->lchild!=NULL)
			ptr=ptr->lchild;
	return ptr;
}/*End of min_nrec()*/

struct node *max_nrec(struct node *ptr)
{
	if(ptr!=NULL)
		while(ptr->rchild!=NULL)
			ptr=ptr->rchild;
	return ptr;
}/*End of max_nrec()*/

void nrec_pre(struct node *root)
{
	struct node *ptr = root;
	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	psh_stack(ptr);
	while( !stack_empty() )
	{
		ptr = pop_stack();
            printf("%d  ",ptr->info);
		if(ptr->rchild!=NULL)
			push_stack(ptr->rchild);
		if(ptr->lchild!=NULL)
			push_stack(ptr->lchild);
	}
	printf("\n");
}/*End of nrec_pre*/

void nrec_in(struct node *root)
{
	struct node *ptr=root;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	while(1)
	{
      while(ptr->lchild!=NULL )
		{
			push_stack(ptr);
			ptr = ptr->lchild;
		}

		while( ptr->rchild==NULL )
		{
			printf("%d  ",ptr->info);
			if(stack_empty())
				return;
			ptr = pop_stack();
		}
		printf("%d  ",ptr->info);
		ptr = ptr->rchild;
	}
	printf("\n");
}/*End of nre
c_in( )*/

void nrec_post(struct node *root)
{
	struct node *ptr = root;
	struct node *q;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	q = root;
	while(1)
	{
		while(ptr->lchild!=NULL)
		{
			push_stack(ptr);
			ptr=ptr->lchild;
		}

		while( ptr->rchild==NULL || ptr->rchild==q )
		{
			printf("%d  ",ptr->info);
			q = ptr;
			if( stack_empty() )
				return;
			ptr = pop_stack();
		}
		push_stack(ptr);
		ptr = ptr->rchild;
	}
	printf("\n");
}/*End of nrec_post( )*/

void level_trav(struct node *root)
{
	struct node *ptr = root;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}

	insert_queue(ptr);

	while( !queue_empty() ) /*Loop until queue is not empty*/
	{
		ptr=del_queue();
		printf("%d ",ptr->info);
		if(ptr->lchild!=NULL)
			insert_queue(ptr->lchild);
		if(ptr->rchild!=NULL)
			insert_queue(ptr->rchild);
	}
	printf("\n");
}/*End of level_trav( )*/

/*Functions for implementation of queue*/
void insert_queue(struct node *item)
{
	if(rear==MAX-1)
	{
		printf("Queue Overflow\n");
		return;
	}
	if(front==-1)  /*If queue is initially empty*/
		front=0;
	rear=rear+1;
	queue[rear]=item ;
}/*End of insert()*/

struct node *del_queue()
{
	struct node *item;
	if(front==-1 || front==rear+1)
	{
		printf("Queue Underflow\n");
		return 0;
	}
	item=queue[front];
	front=front+1;
	return item;
}/*End of del_queue()*/

int queue_empty()
{
	if(front==-1 || front==rear+1)
		return 1;
	else
		return 0;
}

/*Functions for implementation of stack*/
void push_stack(struct node *item)
{
	if(top==(MAX-1))
	{
		printf("Stack Overflow\n");
		return;
	}
	top=top+1;
	stack[top]=item;
}/*End of push_stack()*/

struct node *pop_stack()
{
	struct node *item;
	if(top==-1)
	{
		printf("Stack Underflow....\n");
		exit(1);
	}
	item=stack[top];
	top=top-1;
	return item;
}/*End of pop_stack()*/

int stack_empty()
{
	if(top==-1)
		return 1;
	else
		return 0;
} /*End of stack_empty*/




// A C / C++ program for Prim's Minimum Spanning Tree (MST) algorithm. 
// The program is for adjacency matrix representation of the graph
 
#include <stdio.h>
#include <limits.h>
 
// Number of vertices in the graph
#define V 5
 
// A utility function to find the vertex with minimum key value, from
// the set of vertices not yet included in MST
int minKey(int key[], bool mstSet[])
{
   // Initialize min value
   int min = INT_MAX, min_index;
 
   for (int v = 0; v < V; v++)
     if (mstSet[v] == false && key[v] < min)
         min = key[v], min_index = v;
 
   return min_index;
}
 
// A utility function to print the constructed MST stored in parent[]
int printMST(int parent[], int n, int graph[V][V])
{
   printf("Edge   Weight\n");
   for (int i = 1; i < V; i++)
      printf("%d - %d    %d \n", parent[i], i, graph[i][parent[i]]);
}
 
// Function to construct and print MST for a graph represented using adjacency
// matrix representation
void primMST(int graph[V][V])
{
     int parent[V]; // Array to store constructed MST
     int key[V];   // Key values used to pick minimum weight edge in cut
     bool mstSet[V];  // To represent set of vertices not yet included in MST
 
     // Initialize all keys as INFINITE
     for (int i = 0; i < V; i++)
        key[i] = INT_MAX, mstSet[i] = false;
 
     // Always include first 1st vertex in MST.
     key[0] = 0;     // Make key 0 so that this vertex is picked as first vertex
     parent[0] = -1; // First node is always root of MST 
 
     // The MST will have V vertices
     for (int count = 0; count < V-1; count++)
     {
        // Pick the minimum key vertex from the set of vertices
        // not yet included in MST
        int u = minKey(key, mstSet);
 
        // Add the picked vertex to the MST Set
        mstSet[u] = true;
 
        // Update key value and parent index of the adjacent vertices of
        // the picked vertex. Consider only those vertices which are not yet
        // included in MST
        for (int v = 0; v < V; v++)
 
           // graph[u][v] is non zero only for adjacent vertices of m
           // mstSet[v] is false for vertices not yet included in MST
           // Update the key only if graph[u][v] is smaller than key[v]
          if (graph[u][v] && mstSet[v] == false && graph[u][v] <  key[v])
             parent[v]  = u, key[v] = graph[u][v];
     }
 
     // print the constructed MST
     printMST(parent, V, graph);
}
 
 
// driver program to test above function
int main()
{
   /* Let us create the following graph
          2    3
      (0)--(1)--(2)
       |   / \   |
      6| 8/   \5 |7
       | /     \ |
      (3)-------(4)
            9          */
   int graph[V][V] = {{0, 2, 0, 6, 0},
                      {2, 0, 3, 8, 5},
                      {0, 3, 0, 0, 7},
                      {6, 8, 0, 0, 9},
                      {0, 5, 7, 9, 0},
                     };
 
    // Print the solution
    primMST(graph);
 
    return 0;
}


INDEX:
1.tree from inorder to preorder(1)
2.tree from inorder and postorder (7)
3.binary tree (14)
4. Recursive operations in Binary Search Tree(25)
5. Non recursive operations in Binary Search Tree(33)


1. Program to construct a binary tree from inorder and preorder
#include<stdio.h>
#include<stdlib.h>

struct treenode
{
	int info;
	struct treenode *lchild;
	struct treenode *rchild;
}*root=NULL;

struct listnode
{
	struct listnode *prev;
	int info;
	struct listnode *next;
}*pre=NULL, *in=NULL;

void display(struct treenode *ptr,int level);
struct listnode *addtoempty(struct listnode *start,int data);
struct listnode *addatend(struct listnode *start,int data);
struct listnode *create_list(struct listnode *start, int n);
struct treenode *construct(struct listnode *inptr,struct listnode *preptr, int num);
void inorder(struct treenode *ptr);
void postorder(struct treenode *ptr);
void preorder(struct treenode *ptr);

main( )
{
	int n;
	
	printf("Enter the number of nodes  :  ");
	scanf("%d",&n);

	printf("Enter inorder\n");
	in = create_list(in, n);

	printf("Enter preorder\n");
	pre=create_list(pre, n);

	root = construct(in,pre,n);

	printf("Inorder : ");  inorder(root);
	printf("\nPostorder : ");  postorder(root);
	printf("\nPreorder : "); preorder(root);
	printf("\n\nTree is : \n");
	display(root,0);
	printf("\n");
}

struct treenode *construct(struct listnode *inptr,struct listnode *preptr, int num )
{
	struct treenode *temp;
	struct listnode *q;

	int i,j;
	if(num==0)
		return NULL;
	
	temp=(struct treenode *)malloc(sizeof(struct treenode));
	temp->info=preptr->info;
	temp->lchild = NULL;
	temp->rchild = NULL;

	if(num==1)/*if only one node in tree */
		return temp;
	
	q = inptr;	
	for(i=0; q->info != preptr->info; i++)
		q = q->next;
	
	/*Now q points to root node in inorder list and 
	 and number of nodes in its left subtree is i*/
	 
	/*For left subtree*/
	temp->lchild = construct(inptr, preptr->next, i);
	
	/*For right subtree*/
	for(j=1;j<=i+1;j++)
		preptr=preptr->next;
	temp->rchild = construct(q->next, preptr, num-i-1);
	 
	return temp;
}/*End of construct()*/

void display(struct treenode *ptr,int level)
{
	int i;
	if ( ptr!=NULL )
	{
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/

struct listnode *create_list(struct listnode *start, int n)
{
	int i, data;
	start=NULL;
	for(i=1;i<=n;i++)
	{
		printf("Enter the element to be inserted : ");
		scanf("%d",&data);
		if(start==NULL)
			start=addtoempty(start,data);
		else
			start=addatend(start,data);	
	}
	return start;
}/*End of create_list()*/

struct listnode *addtoempty(struct listnode *start,int data)
{
	struct listnode *tmp;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	tmp->prev=NULL;
	tmp->next=NULL;
	start=tmp;
	return start;
}/*End of addtoempty( )*/
struct listnode *addatend(struct listnode *start,int data)
{
	struct listnode *tmp,*p;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	p=start;
	while(p->next!=NULL)
		p=p->next;
	p->next=tmp;
	tmp->next=NULL;
	tmp->prev=p;
	return start;
}/*End of addatend( )*/

void inorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/
void postorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

void preorder(struct treenode *ptr)
{
	if(root==NULL)
	{printf("Tree is empty");
		return;}
	if(ptr!=NULL)
	{printf("%d  ",ptr->info);
preorder(ptr->lchild);
		preorder(ptr->rchild);
	}}/*End of preorder( )*/


2 .Program for constructing a binary tree from inorder and postorder 

#include<stdio.h>
#include<stdlib.h>

struct treenode
{
	int info;
	struct treenode *lchild;
	struct treenode *rchild;
}*root=NULL;

struct listnode
{
	struct listnode *prev;
	int info;
	struct listnode *next;
}*post=NULL, *in=NULL;

void display(struct treenode *ptr,int level);
struct listnode *addtoempty(struct listnode *start,int data);
struct listnode *addatend(struct listnode *start,int data);
struct listnode *create_list(struct listnode *start, int n);
struct treenode *construct(struct listnode *inptr,struct listnode *postptr, int num);
void inorder(struct treenode *ptr);
void preorder(struct treenode *ptr);
void postorder(struct treenode *ptr);

main()
{
	int n;

	printf("Enter the number of nodes  :  ");
	scanf("%d",&n);

	printf("Enter inorder\n");
	in = create_list(in,n);

	printf("Enter postorder\n");
	post = create_list(post,n);

	root = construct(in,post,n);

	printf("Inorder : ");  inorder(root);
	printf("\nPostorder : ");  postorder(root);
	printf("\nPreorder : "); preorder(root);
	printf("\n\nTree is : \n");
	display(root,0);
	printf("\n");
}/*End of main()*/

struct treenode *construct(struct listnode *inptr,struct listnode *postptr, int num)
{
	struct treenode *temp;
	struct listnode *q, *ptr;

	int i,j;
	if(num==0)
		return NULL;
	
	ptr=postptr;
	for(i=1;i<num;i++)
		ptr = ptr->next;

	/*Now ptr points to last node of postorder which is root*/
	
	temp=(struct treenode *)malloc(sizeof(struct treenode));
	temp->info=ptr->info;
	temp->lchild = NULL;
	temp->rchild = NULL;

	if(num==1)/*if only one node in tree */
		return temp;
		
	q=inptr;
	for(i=0; q->info!=ptr->info; i++ )
		q = q->next;

	/*Now i denotes the number of nodes in left subtree
	and q points to root node in inorder list*/	
	
	/*For left subtree*/
	temp->lchild = construct(inptr, postptr, i);
			
	/*For right subtree*/
	for(j=1;j<=i;j++)
		postptr = postptr->next;
	temp->rchild = construct(q->next, postptr, num-i-1);
		
	return temp;
}/*End of construct()*/

struct listnode *create_list(struct listnode *start, int n)
{
	int i,data;
	start=NULL;
	for(i=1;i<=n;i++)
	{
		printf("Enter the element to be inserted : ");
		scanf("%d",&data);
		if(start==NULL)
			start=addtoempty(start,data);
		else
			start=addatend(start,data);	
	}
	return start;
}/*End of create_list()*/

struct listnode *addtoempty(struct listnode *start,int data)
{
	struct listnode *tmp;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	tmp->prev=NULL;
	tmp->next=NULL;
	start=tmp;
	return start;
}/*End of addtoempty( )*/

struct listnode *addatend(struct listnode *start,int data)
{
	struct listnode *tmp,*p;
	tmp=malloc(sizeof(struct listnode));
	tmp->info=data;
	p=start;
	while(p->next!=NULL)
		p=p->next;
	p->next=tmp;
	tmp->next=NULL;
	tmp->prev=p;
	return start;
}/*End of addatend( )*/

void inorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/
void postorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

void preorder(struct treenode *ptr)
{
	if(root==NULL)
	{
		printf("Tree is empty");
		return;
	}
	if(ptr!=NULL)
	{
		printf("%d  ",ptr->info);
		preorder(ptr->lchild);
		preorder(ptr->rchild);
	}
}/*End of preorder( )*/

void display(struct treenode *ptr,int level)
{
	int i;
	if(ptr!=NULL)
	{
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/


















3.Binary tree
/*Recursive operations in Binary Search Tree*/
/*display() function displays the tree from left to right instead of top to bottom
root is displayed at the leftmost position*/

#include<stdio.h>
#include<stdlib.h>
#define STOP getchar()

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search(struct node *ptr, int skey);
struct node *insert(struct node *ptr, int ikey);
struct node *del(struct node *ptr, int dkey);

int height(struct node *ptr);
struct node *minimum(struct node *ptr);
struct node *maximum(struct node *ptr);
void preorder(struct node *ptr);
void inorder(struct node *ptr);
void postorder(struct node *ptr);
int height(struct node *ptr);
void display(struct node *ptr,int level);

main( )
{
	struct node *root=NULL,*ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Height of tree\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		printf("\nTree is -->\n.......................\n\n");
		display(root,0);
		printf("\n\n.......................\n\n");

		switch(choice)
		{
		case 1: 
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search(root, k);
			if(ptr==NULL)
				printf("Key not present\n");
			else
				printf("Key present\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			printf("\nInserting %d\n\n",k);
			root = insert(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del(root,k);
			break;
		 case 4:
			preorder(root);
			break;
		 case 5:
			inorder(root);
			break;
		 case 6:
			postorder(root);
			break;
		 case 7:
			 printf("Height of tree is %d\n", height(root));
			 break;
		 case 8:
			ptr = minimum(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = maximum(root); 	
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		 case 9:
			exit(1);
		 default:
			printf("Wrong choice\n");
		}/*End of switch */
	}/*End of while */
}/*End of main( )*/

struct node *search(struct node *ptr, int skey)
{
	
	if(ptr!=NULL)
		printf("search() fn called for ptr = Address of %d\n", ptr->info);
	STOP;
	
	if(ptr==NULL)	
	{	
		printf("search() fn called for ptr = NULL\n");
		printf("Base Case 1 Reached, Recursion stops\n");
		printf("key %d is not found in the tree\n", skey);
		return NULL;
	}
	else if(skey < ptr->info)/*search in left subtree*/	
	{
		printf("Search in left subtree of %d\n",ptr->info);
		return search(ptr->lchild, skey);	
	}
	else if(skey > ptr->info)/*search in right subtree*/
	{
		printf("Search in left subtree of %d\n",ptr->info);
		return search(ptr->rchild, skey);
	}

	else 
	{
		printf("Base Case 2 Reached, Recursion stops\n");
		printf("key %d found in the tree\n", skey);
		return ptr;
	}

}

struct node *insert(struct node *ptr, int ikey )
{
	
	if(ptr!=NULL)
		printf("insert() fn called for ptr = Address of %d\n", ptr->info);
	STOP;
	if(ptr==NULL)	
	{
		printf("insert() fn called for ptr = NULL \n");
		printf("Base Case 1 Reached, Recursion stops\n");
		printf("key %d is not in the tree and so it can be inserted\n", ikey);
		ptr = (struct node *) malloc(sizeof(struct node));
		ptr->info = ikey;
		ptr->lchild = NULL;
		ptr->rchild = NULL;
		printf("Now ptr points to %d\n",ptr->info); 
		STOP;
		printf("Unwinding phase begins and all recursive calls are returned\n");
	}
	else if(ikey < ptr->info)	/*Insertion in left subtree*/
	{	
		printf("Insertion to be done in left subtree of %d\n",ptr->info);
		ptr->lchild = insert(ptr->lchild, ikey);
		printf("ptr points to %d and its left child is assigned address of %d\n",ptr->info, ptr->lchild->info);
	}
	else if(ikey > ptr->info)				/*Insertion in right subtree */
	{
		printf("Insertion to be done in right subtree of %d\n",ptr->info);
		ptr->rchild = insert(ptr->rchild, ikey);  
		printf("ptr points to %d and its right child is assigned address of %d\n", ptr->info, ptr->rchild->info);
	}
	else
	{
		printf("Base Case 2 Reached, Recursion stops");
        printf("\nkey %d is already present, can't be inserted\n",ikey);
		STOP;
		printf("Unwinding phase begins and all recursive calls are returned\n");
	}
	STOP;
	printf("Returning address of %d\n\n", ptr->info);
	return(ptr);
}/*End of insert( )*/

struct node *del(struct node *ptr, int dkey)
{
	struct node *tmp, *succ;

	if( ptr == NULL)
	{
		printf("dkey not found\n");
		return(ptr);
	}
	if( dkey < ptr->info )/*delete from left subtree*/
		ptr->lchild = del(ptr->lchild, dkey);
	else if( dkey > ptr->info )/*delete from right subtree*/
		ptr->rchild = del(ptr->rchild, dkey);
	else
	{
		/*Node to be deleted is found*/
		if( ptr->lchild!=NULL  &&  ptr->rchild!=NULL )  /*2 children*/
		{
			succ=ptr->rchild;
			while(succ->lchild)
				succ=succ->lchild;
			ptr->info=succ->info;
			ptr->rchild = del(ptr->rchild, succ->info);
		}
		else	
		{
			tmp = ptr;
			if( ptr->lchild != NULL ) /*only left child*/
				ptr = ptr->lchild;
			else if( ptr->rchild != NULL) /*only right child*/
				ptr = ptr->rchild;
			else	/* no child */
				ptr = NULL;
			free(tmp);
		}						
	}
	return ptr; 
}/*End of del( )*/

struct node *minimum(struct node *ptr)
{
	if(ptr==NULL)
		return NULL;
	else if(ptr->lchild==NULL)
        return ptr;
	else 
		return minimum(ptr->lchild);
}/*End of minimum()*/

struct node *maximum(struct node *ptr)
{
	if(ptr==NULL)	
		return NULL;
	else if(ptr->rchild==NULL)
        return ptr;
	else 
		return maximum(ptr->rchild);
}/*End of maximum()*/

void preorder(struct node *ptr)
{
	if(ptr == NULL )	/*Base Case*/
		return;
	else
	{
		printf("%d  ",ptr->info);
		preorder(ptr->lchild);
		preorder(ptr->rchild);
	}
}/*End of preorder( )*/

void inorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	else
	{
		inorder(ptr->lchild);
		printf("%d  ",ptr->info);
		inorder(ptr->rchild);
	}
}/*End of inorder( )*/

void postorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	else
	{
		postorder(ptr->lchild);
		postorder(ptr->rchild);
		printf("%d  ",ptr->info);
	}
}/*End of postorder( )*/

int height(struct node *ptr)
{
	int h_left, h_right; 

	if (ptr == NULL) /*Base Case*/
		return 0; 
	
	h_left =  height(ptr->lchild); 
	printf("Height of left subtree of %d is %d\n", ptr->info, h_left);
	
	h_right = height(ptr->rchild); 
	printf("Height of right subtree of %d is %d\n", ptr->info, h_right);
	
	if (h_left > h_right) 
	{
		printf("Height of tree %d is %d\n", ptr->info, 1 + h_left);
		return 1 + h_left; 
	}
	else 
	{
		printf("Height of subtree %d is %d\n", ptr->info, 1 + h_right);
		return 1 + h_right; 
	}
}/*End of height()*/

void display(struct node *ptr,int level)
{
	int i;
	if(ptr == NULL )/*Base Case*/
		return;
	else
    {
		display(ptr->rchild, level+1);
		printf("\n");
		for (i = 0; i < level; i++)
			printf("    ");
		printf("%d", ptr->info);
		display(ptr->lchild, level+1);
	}
}/*End of display()*/



















4. Recursive operations in Binary Search Tree
#include<stdio.h>
#include<stdlib.h>

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search(struct node *ptr, int skey);
struct node *insert(struct node *ptr, int ikey);
struct node *del(struct node *ptr, int dkey);
struct node *Min(struct node *ptr);
struct node *Max(struct node *ptr);
int height(struct node *ptr);
void preorder(struct node *ptr);
void inorder(struct node *ptr);
void postorder(struct node *ptr);

main( )
{
	struct node *root=NULL,*ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Height of tree\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		switch(choice)
		{
		case 1: 
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search(root, k);
			if(ptr!=NULL)
				printf("Key found\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			root = insert(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del(root,k);
			break;
		 case 4:
			preorder(root);
			break;
		 case 5:
			inorder(root);
			break;
		 case 6:
			postorder(root);
			break;
		 case 7:
			 printf("Height of tree is %d\n", height(root));
			 break;
		 case 8:
			ptr = Min(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = Max(root); 	
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		 case 9:
			exit(1);
		 default:
			printf("Wrong choice\n");
		}/*End of switch */
	}/*End of while */
}/*End of main( )*/

struct node *search(struct node *ptr, int skey)
{
	if(ptr==NULL)   
	{	
		printf("key not found\n");
		return NULL;
	}
	else if(skey < ptr->info)/*search in left subtree*/	
		return search(ptr->lchild, skey);	
	else if(skey > ptr->info)/*search in right subtree*/
		return search(ptr->rchild, skey);
	else /*skey found*/
		return ptr;
}/*End of search()*/

struct node *insert(struct node *ptr, int ikey )
{
	if(ptr==NULL)	
	{
		ptr = (struct node *) malloc(sizeof(struct node));
		ptr->info = ikey;
		ptr->lchild = NULL;
		ptr->rchild = NULL;
	}
	else if(ikey < ptr->info)	/*Insertion in left subtree*/
		ptr->lchild = insert(ptr->lchild, ikey);
	else if(ikey > ptr->info)	/*Insertion in right subtree */
		ptr->rchild = insert(ptr->rchild, ikey);  
	else
		printf("Duplicate key\n");
	return ptr;
}/*End of insert( )*/

struct node *del(struct node *ptr, int dkey)
{
	struct node *tmp, *succ;

	if( ptr == NULL)
	{
		printf("dkey not found\n");
		return(ptr);
	}
	if( dkey < ptr->info )/*delete from left subtree*/
		ptr->lchild = del(ptr->lchild, dkey);
	else if( dkey > ptr->info )/*delete from right subtree*/
		ptr->rchild = del(ptr->rchild, dkey);
	else
	{
		/*key to be deleted is found*/
		if( ptr->lchild!=NULL  &&  ptr->rchild!=NULL )  /*2 children*/
		{
			succ=ptr->rchild;
			while(succ->lchild)
				succ=succ->lchild;
			ptr->info=succ->info;
			ptr->rchild = del(ptr->rchild, succ->info);
		}
		else	
		{
			tmp = ptr;
			if( ptr->lchild != NULL ) /*only left child*/
				ptr = ptr->lchild;
			else if( ptr->rchild != NULL) /*only right child*/
				ptr = ptr->rchild;
			else	/* no child */
				ptr = NULL;
			free(tmp);
		}						
	}
	return ptr; 
}/*End of del( )*/

struct node *Min(struct node *ptr)
{
	if(ptr==NULL)
		return NULL;
	else if(ptr->lchild==NULL)
        return ptr;
	else 
		return Min(ptr->lchild);
}/*End of min()*/

struct node *Max(struct node *ptr)
{
	if(ptr==NULL) 
		return NULL;
	else if(ptr->rchild==NULL)
        return ptr;
	else 
		return Max(ptr->rchild);
}/*End of max()*/

void preorder(struct node *ptr)
{
	if(ptr == NULL )	/*Base Case*/
		return;
	printf("%d  ",ptr->info);
	preorder(ptr->lchild);
	preorder(ptr->rchild);
}/*End of preorder( )*/

void inorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	inorder(ptr->lchild);
	printf("%d  ",ptr->info);
	inorder(ptr->rchild);
}/*End of inorder( )*/

void postorder(struct node *ptr)
{
	if(ptr == NULL )/*Base Case*/
		return;
	postorder(ptr->lchild);
	postorder(ptr->rchild);
	printf("%d  ",ptr->info);
	
}/*End of postorder( )*/

int height(struct node *ptr)
{
	int h_left, h_right; 

	if (ptr == NULL) /*Base Case*/
		return 0; 

	h_left =  height(ptr->lchild); 
	h_right = height(ptr->rchild); 

	if (h_left > h_right) 
		return 1 + h_left; 
	else 
		return 1 + h_right; 
}/*End of height()*/




















5. Non recursive operations in Binary Search Tree

#include<stdio.h>
#include<stdlib.h>
#define MAX 50

struct node
{
	struct node *lchild;
	int info;
	struct node *rchild;
};

struct node *search_nrec(struct node *root, int skey);
struct node *min_nrec(struct node *root);
struct node *max_nrec(struct node *root);
struct node *insert_nrec(struct node *root, int ikey );
struct node *del_nrec(struct node *root, int dkey);
struct node *case_c(struct node *root, struct node *par,struct node *ptr);
struct node *case_b(struct node *root,struct node *par,struct node *ptr);
struct node *case_a(struct node *root, struct node *par,struct node *ptr );
struct node *del_nrec1(struct node *root, int item);
void nrec_pre(struct node *root);
void nrec_in(struct node *root);
void nrec_post(struct node *root);
void level_trav(struct node *root);


struct node *queue[MAX];
int front=-1,rear=-1;
void insert_queue(struct node *item);
struct node *del_queue();
int queue_empty();

struct node *stack[MAX];
int top=-1;
void push_stack(struct node *item);
struct node *pop_stack();
int stack_empty();

main( )
{
	struct node *root=NULL, *ptr;
	int choice,k;

	while(1)
	{
		printf("\n");
		printf("1.Search\n");
		printf("2.Insert\n");
		printf("3.Delete\n");
		printf("4.Preorder Traversal\n");
		printf("5.Inorder Traversal\n");
		printf("6.Postorder Traversal\n");
		printf("7.Level order traversal\n");
		printf("8.Find minimum and maximum\n");
		printf("9.Quit\n");
		printf("Enter your choice : ");
		scanf("%d",&choice);

		switch(choice)
		{
		case 1:
			printf("Enter the key to be searched : ");
			scanf("%d",&k);
			ptr = search_nrec(root, k);
			if(ptr==NULL)
				printf("Key not present\n");
			else
				printf("Key present\n");
			break;
		case 2:
			printf("Enter the key to be inserted : ");
			scanf("%d",&k);
			root = insert_nrec(root, k);
			break;
		case 3:
			printf("Enter the key to be deleted : ");
			scanf("%d",&k);
			root = del_nrec(root, k);
			break;
		case 4:
			nrec_pre(root);
			break;
		case 5:
			nrec_in(root);
			break;
		case 6:
			nrec_post(root);
			break;
		case 7:
			level_trav(root);
			break;
		case 8:
			ptr = min_nrec(root);
			if(ptr!=NULL)
				printf("Minimum key is %d\n", ptr->info );
			ptr = max_nrec(root);
			if(ptr!=NULL)
				printf("Maximum key is %d\n", ptr->info );
			break;
		case 9:
			exit(1);
		default:
			printf("Wrong choice\n");
		}/*End of switch*/
	}/*End of while */
}/*End of main( )*/

struct node *search_nrec(struct node *ptr, int skey)
{
	while(ptr!=NULL)
	{
		if(skey < ptr->info)
			ptr = ptr->lchild; /*Move to left child*/
		else if(skey > ptr->info)
			ptr = ptr->rchild;  /*Move to right child */
		else	/*skey found*/
			return ptr;
	}
	return NULL;
}/*End of search_nrec()*/

struct node *insert_nrec(struct node *root, int ikey)
{
	struct node *tmp,*par,*ptr;

	ptr = root;
	par = NULL;

	while( ptr!=NULL)
	{
		par = ptr;
		if(ikey < ptr->info)
			ptr = ptr->lchild;
		else if( ikey > ptr->info )
			ptr = ptr->rchild;
		else
		{
			printf("Duplicate key");
			return root;
		}
	}

	tmp=(struct node *)malloc(sizeof(struct node));
	tmp->info=ikey;
	tmp->lchild=NULL;
	tmp->rchild=NULL;

	if(par==NULL)
		root=tmp;
	else if( ikey < par->info )
		par->lchild=tmp;
	else
		par->rchild=tmp;

	return root;
}/*End of insert_nrec( )*/

struct node *del_nrec1(struct node *root, int dkey)
{
	struct node *par,*ptr, *child, *succ, *parsucc;

	ptr = root;
	par = NULL;
	while( ptr!=NULL)
	{
		if( dkey == ptr->info)
			break;
		par = ptr;
		if(dkey < ptr->info)
			ptr = ptr->lchild;
		else
			ptr = ptr->rchild;
	}

	if(ptr==NULL)
	{
		printf("dkey not present in tree");
		return root;
	}

	/*Case C: 2 children*/
	if(ptr->lchild!=NULL && ptr->rchild!=NULL)
	{
		parsucc = ptr;
		succ = ptr->rchild;
		while(succ->lchild!=NULL)
		{
			parsucc = succ;
			succ = succ->lchild;
		}
		ptr->info = succ->info;
		ptr = succ;
		par = parsucc;
	}

	/*Case B and Case A : 1 or no child*/
	if(ptr->lchild!=NULL) /*node to be deleted has left child */
		child=ptr->lchild;
	else                /*node to be deleted has right child */
		child=ptr->rchild;

	if(par==NULL )   /*node to be deleted is root node*/
		root=child;
	else if( ptr==par->lchild)/*node is left child of its parent*/
		par->lchild=child;
	else       /*node is right child of its parent*/
		par->rchild=child;
	free(ptr);
	return root;
}

struct node *del_nrec(struct node *root, int dkey)
{
	struct node *par,*ptr;

	ptr = root;
	par = NULL;
	while(ptr!=NULL)
	{
		if( dkey == ptr->info)
			break;
		par = ptr;
		if(dkey < ptr->info)
			ptr = ptr->lchild;
		else
			ptr = ptr->rchild;
	}

	if(ptr==NULL)
		printf("dkey not present in tree\n");
	else if(ptr->lchild!=NULL && ptr->rchild!=NULL)/*2 children*/
		root = case_c(root,par,ptr);
	else if(ptr->lchild!=NULL )/*only left child*/
        root = case_b(root, par,ptr);
	else if(ptr->rchild!=NULL)/*only right child*/
        root = case_b(root, par,ptr);
	else /*no child*/
		root = case_a(root,par,ptr);

	return root;
}/*End of del_nrec( )*/

struct node *case_a(struct node *root, struct node *par,struct node *ptr )
{
	if(par==NULL) /*root node to be deleted*/
		root=NULL;
	else if(ptr==par->lchild)
		par->lchild=NULL;
	else
		par->rchild=NULL;
	free(ptr);
	return root;
}/*End of case_a( )*/

struct node *case_b(struct node *root,struct node *par,struct node *ptr)
{
	struct node *child;

	/*Initialize child*/
	if(ptr->lchild!=NULL) /*node to be deleted has left child */
		child=ptr->lchild;
	else                /*node to be deleted has right child */
		child=ptr->rchild;

	if(par==NULL )   /*node to be deleted is root node*/
		root=child;
	else if( ptr==par->lchild)   /*node is left child of its parent*/
		par->lchild=child;
	else                  /*node is right child of its parent*/
		par->rchild=child;
	free(ptr);
	return root;
}/*End of case_b( )*/

struct node *case_c(struct node *root, struct node *par,struct node *ptr)
{
	struct node *succ,*parsucc;

	/*Find inorder successor and its parent*/
	parsucc = ptr;
	succ = ptr->rchild;
	while(succ->lchild!=NULL)
	{
		parsucc = succ;
		succ = succ->lchild;
	}

	ptr->info = succ->info;

	if(succ->lchild==NULL && succ->rchild==NULL)
		root = case_a(root, parsucc,succ);
	else
		root = case_b(root, parsucc,succ);
	return root;
}/*End of case_c( )*/

struct node *min_nrec(struct node *ptr)
{
	if(ptr!=NULL)
		while(ptr->lchild!=NULL)
			ptr=ptr->lchild;
	return ptr;
}/*End of min_nrec()*/

struct node *max_nrec(struct node *ptr)
{
	if(ptr!=NULL)
		while(ptr->rchild!=NULL)
			ptr=ptr->rchild;
	return ptr;
}/*End of max_nrec()*/

void nrec_pre(struct node *root)
{
	struct node *ptr = root;
	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	psh_stack(ptr);
	while( !stack_empty() )
	{
		ptr = pop_stack();
            printf("%d  ",ptr->info);
		if(ptr->rchild!=NULL)
			push_stack(ptr->rchild);
		if(ptr->lchild!=NULL)
			push_stack(ptr->lchild);
	}
	printf("\n");
}/*End of nrec_pre*/

void nrec_in(struct node *root)
{
	struct node *ptr=root;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	while(1)
	{
      while(ptr->lchild!=NULL )
		{
			push_stack(ptr);
			ptr = ptr->lchild;
		}

		while( ptr->rchild==NULL )
		{
			printf("%d  ",ptr->info);
			if(stack_empty())
				return;
			ptr = pop_stack();
		}
		printf("%d  ",ptr->info);
		ptr = ptr->rchild;
	}
	printf("\n");
}/*End of nre
c_in( )*/

void nrec_post(struct node *root)
{
	struct node *ptr = root;
	struct node *q;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}
	q = root;
	while(1)
	{
		while(ptr->lchild!=NULL)
		{
			push_stack(ptr);
			ptr=ptr->lchild;
		}

		while( ptr->rchild==NULL || ptr->rchild==q )
		{
			printf("%d  ",ptr->info);
			q = ptr;
			if( stack_empty() )
				return;
			ptr = pop_stack();
		}
		push_stack(ptr);
		ptr = ptr->rchild;
	}
	printf("\n");
}/*End of nrec_post( )*/

void level_trav(struct node *root)
{
	struct node *ptr = root;

	if( ptr==NULL )
	{
		printf("Tree is empty\n");
		return;
	}

	insert_queue(ptr);

	while( !queue_empty() ) /*Loop until queue is not empty*/
	{
		ptr=del_queue();
		printf("%d ",ptr->info);
		if(ptr->lchild!=NULL)
			insert_queue(ptr->lchild);
		if(ptr->rchild!=NULL)
			insert_queue(ptr->rchild);
	}
	printf("\n");
}/*End of level_trav( )*/

/*Functions for implementation of queue*/
void insert_queue(struct node *item)
{
	if(rear==MAX-1)
	{
		printf("Queue Overflow\n");
		return;
	}
	if(front==-1)  /*If queue is initially empty*/
		front=0;
	rear=rear+1;
	queue[rear]=item ;
}/*End of insert()*/

struct node *del_queue()
{
	struct node *item;
	if(front==-1 || front==rear+1)
	{
		printf("Queue Underflow\n");
		return 0;
	}
	item=queue[front];
	front=front+1;
	return item;
}/*End of del_queue()*/

int queue_empty()
{
	if(front==-1 || front==rear+1)
		return 1;
	else
		return 0;
}

/*Functions for implementation of stack*/
void push_stack(struct node *item)
{
	if(top==(MAX-1))
	{
		printf("Stack Overflow\n");
		return;
	}
	top=top+1;
	stack[top]=item;
}/*End of push_stack()*/

struct node *pop_stack()
{
	struct node *item;
	if(top==-1)
	{
		printf("Stack Underflow....\n");
		exit(1);
	}
	item=stack[top];
	top=top-1;
	return item;
}/*End of pop_stack()*/

int stack_empty()
{
	if(top==-1)
		return 1;
	else
		return 0;
} /*End of stack_empty*/




///////////////////////dfs in adjacency matrix
#include<stdio.h>
 
void DFS(int);
int G[10][10],visited[10],n;    //n is no of vertices and graph is sorted in array G[10][10]
 
void main()
{
    int i,j;
    printf("Enter number of vertices:");
   
    scanf("%d",&n);
 
    //read the adjecency matrix
    printf("\nEnter adjecency matrix of the graph:");
   
    for(i=0;i<n;i++)
       for(j=0;j<n;j++)
            scanf("%d",&G[i][j]);
 
    //visited is initialized to zero
   for(i=0;i<n;i++)
        visited[i]=0;
 
    DFS(0);
}
 
void DFS(int i)
{
    int j;
    printf("\n%d",i);
    visited[i]=1;
    
    for(j=0;j<n;j++)
       if(!visited[j]&&G[i][j]==1)
            DFS(j);
}



/////////////////////////////////bfs and dfs using adjacency list!

#include<conio.h>
#include<stdio.h>
#include<stdlib.h>
#define MAX 20

typedef struct Q
{
 int data[MAX];
 int R,F;
}Q;

typedef struct node
{
 struct node *next;
 int vertex;
}node;

void enqueue(Q *,int);
int dequque(Q *);
int empty(Q *);
int full(Q *);
void BFS(int);
void readgraph();      //create an adjecency list
void insert(int vi,int vj);     //insert an edge (vi,vj)in adj.list
void DFS(int i);
int visited[MAX];
node *G[20];          //heads of the linked list
int n;                 // no of nodes

void main()
{
 int i,op;
 clrscr();
 do
   { printf("\n\n1)Create\n2)BFS\n3)DFS\n4)Quit");
     printf("\nEnter Your Choice: ");
     scanf("%d",&op);
     switch(op)
      { case 1: readgraph();break;
        case 2: printf("\nStarting Node No. : ");
         scanf("%d",&i);
         BFS(i);break;
        case 3:  for(i=0;i<n;i++)
    visited[i]=0;
         printf("\nStarting Node No. : ");
         scanf("%d",&i);
         DFS(i);break;
       }
    }while(op!=4);
}


void BFS(int v)
{
 int w,i,visited[MAX];
 Q q;

 node *p;
 q.R=q.F=-1;              //initialise
 for(i=0;i<n;i++)
  visited[i]=0;
 enqueue(&q,v);
 printf("\nVisit\t%d",v);
 visited[v]=1;
 while(!empty(&q))
 {
  v=dequeue(&q);
  //insert all unvisited,adjacent vertices of v into queue
  for(p=G[v];p!=NULL;p=p->next)
  {
   w=p->vertex;
   if(visited[w]==0)
   {
    enqueue(&q,w);
    visited[w]=1;
    printf("\nvisit\t%d",w);
   }
  }
 }
}

void DFS(int i)
{
 node *p;
 printf("\n%d",i);
 p=G[i];
 visited[i]=1;
 while(p!=NULL)
 {
  i=p->vertex;
  if(!visited[i])
   DFS(i);
  p=p->next;
 }
}


int empty(Q *P)
{
 if(P->R==-1)
  return(1);
 return(0);
}

int full(Q *P)
{
 if(P->R==MAX-1)
  return(1);
 return(0);
}

void enqueue(Q *P,int x)
{
 if(P->R==-1)
 {
  P->R=P->F=0;
  P->data[P->R]=x;
 }
 else
 {
  P->R=P->R+1;
  P->data[P->R]=x;
 }
}

int dequeue(Q *P)
{
 int x;
 x=P->data[P->F];
 if(P->R==P->F)
 {
  P->R=-1;
  P->F=-1;
 }
 else
  P->F=P->F+1;
 return(x);
}

void readgraph()
{  int i,vi,vj,no_of_edges;
 printf("\nEnter no. of vertices :");
 scanf("%d",&n);
 //initialise G[] with NULL
 for(i=0;i<n;i++)
  G[i]=NULL;
 //read edges and insert them in G[]
 printf("\nEnter no of edges :");
 scanf("%d",&no_of_edges);
 for(i=0;i<no_of_edges;i++)
 {
  printf("\nEnter an edge (u,v)  :");
  scanf("%d%d",&vi,&vj);
  insert(vi,vj);
  insert(vj,vi);
 }
}

void insert(int vi,int vj)
{
 node *p,*q;
 //acquire memory for the new node
 q=(node *)malloc(sizeof(node));
 q->vertex=vj;
 q->next=NULL;
 //insert the node in the linked list for the vertex no. vi
 if(G[vi]==NULL)
  G[vi]=q;
 else
 {
  // go to the end of linked list
  p=G[vi];
  while(p->next!=NULL)
   p=p->next;
  p->next=q;
 }



////////////////////////////dfs using adjeacency list
#include<stdio.h>  

typedef struct node
{
    struct node *next;
    int vertex;
}node;

node *G[20];  

int visited[20];
int n;
void read_graph();
void insert(int,int); 
void DFS(int);

void main()
{
    int i;
    read_graph();
    //initialised visited to 0

    for(i=0;i<n;i++)
        visited[i]=0;

    DFS(0);
}

void DFS(int i)
{
    node *p;

    printf("\n%d",i);
    p=G[i];
    visited[i]=1;
    while(p!=NULL)
    {
        i=p->vertex;
        if(!visited[i])
            DFS(i);
        p=p->next;
    }
}

void read_graph()
{
    int i,vi,vj,no_of_edges;
    printf("Enter number of vertices:");

    scanf("%d",&n);

    //initialise G[] with a null

    for(i=0;i<n;i++)
    {
        G[i]=NULL;
        //read edges and insert them in G[]

        printf("Enter number of edges:");
        scanf("%d",&no_of_edges);

        for(i=0;i<no_of_edges;i++)
        {
            printf("Enter an edge(u,v):");
            scanf("%d%d",&vi,&vj);
            insert(vi,vj);
        }
    }
}

void insert(int vi,int vj)
{
    node *p,*q;

    //acquire memory for the new node
    q=(node*)malloc(sizeof(node));
    q->vertex=vj;
    q->next=NULL;

    //insert the node in the linked list number vi
    if(G[vi]==NULL)
        G[vi]=q;
    else
    {
        //go to end of the linked list
        p=G[vi];

        while(p->next!=NULL)
            p=p->next;
        p->next=q;
    }


/////////////////////////////////bfs in source code
#include<stdio.h>
#include<stdlib.h>
 
#define MAX 100  
 
#define initial 1
#define waiting 2
#define visited 3
 
int n;    
int adj[MAX][MAX];
int state[MAX]; 
void create_graph();
void BF_Traversal();
void BFS(int v);
 
int queue[MAX], front = -1,rear = -1;
void insert_queue(int vertex);
int delete_queue();
int isEmpty_queue();
 
int main()
{
    create_graph();
    BF_Traversal();
    return 0;
}
 
void BF_Traversal()
{
    int v;
    
    for(v=0; v<n; v++) 
        state[v] = initial;
    
    printf("Enter Start Vertex for BFS: \n");
    scanf("%d", &v);
    BFS(v);
}
 
void BFS(int v)
{
    int i;
    
    insert_queue(v);
    state[v] = waiting;
    
    while(!isEmpty_queue())
    {
        v = delete_queue( );
        printf("%d ",v);
        state[v] = visited;
        
        for(i=0; i<n; i++)
        {
            if(adj[v][i] == 1 && state[i] == initial) 
            {
                insert_queue(i);
                state[i] = waiting;
            }
        }
    }
    printf("\n");
}
 
void insert_queue(int vertex)
{
    if(rear == MAX-1)
        printf("Queue Overflow\n");
    else
    {
        if(front == -1) 
            front = 0;
        rear = rear+1;
        queue[rear] = vertex ;
    }
}
 
int isEmpty_queue()
{
    if(front == -1 || front > rear)
        return 1;
    else
        return 0;
}
 
int delete_queue()
{
    int delete_item;
    if(front == -1 || front > rear)
    {
        printf("Queue Underflow\n");
        exit(1);
    }
    
    delete_item = queue[front];
    front = front+1;
    return delete_item;
}
 
void create_graph()
{
    int count,max_edge,origin,destin;
 
    printf("Enter number of vertices : ");
    scanf("%d",&n);
    max_edge = n*(n-1);
 
    for(count=1; count<=max_edge; count++)
    {
        printf("Enter edge %d( -1 -1 to quit ) : ",count);
        scanf("%d %d",&origin,&destin);
 
        if((origin == -1) && (destin == -1))
            break;
 
        if(origin>=n || destin>=n || origin<0 || destin<0)
        {
            printf("Invalid edge!\n");
            count--;
        }
        else
        {
            adj[origin][destin] = 1;
        }
    }


/* C program to implement BFS(breadth-first search) and DFS(depth-first search) algorithm */

#include<stdio.h>

int q[20],top=-1,front=-1,rear=-1,a[20][20],vis[20],stack[20]; 
int delete(); 
void add(int item); 
void bfs(int s,int n); 
void dfs(int s,int n); 
void push(int item); 
int pop();

void main() 
{ 
int n,i,s,ch,j; 
char c,dummy; 
printf("ENTER THE NUMBER VERTICES "); 
scanf("%d",&n); 
for(i=1;i<=n;i++) 
{ 
for(j=1;j<=n;j++) 
{ 
printf("ENTER 1 IF %d HAS A NODE WITH %d ELSE 0 ",i,j); 
scanf("%d",&a[i][j]); 
} 
} 
printf("THE ADJACENCY MATRIX IS\n"); 
for(i=1;i<=n;i++) 
{ 
for(j=1;j<=n;j++) 
{ 
printf(" %d",a[i][j]); 
} 
printf("\n"); 
} 

do 
{ 
for(i=1;i<=n;i++) 
vis[i]=0; 
printf("\nMENU"); 
printf("\n1.B.F.S"); 
printf("\n2.D.F.S"); 
printf("\nENTER YOUR CHOICE"); 
scanf("%d",&ch); 
printf("ENTER THE SOURCE VERTEX :"); 
scanf("%d",&s); 

switch(ch) 
{ 
case 1:bfs(s,n); 
break; 
case 2: 
dfs(s,n); 
break; 
} 
printf("DO U WANT TO CONTINUE(Y/N) ? "); 
scanf("%c",&dummy); 
scanf("%c",&c); 
}while((c=='y')||(c=='Y')); 
}


//**************BFS(breadth-first search) code**************// 
void bfs(int s,int n) 
{ 
int p,i; 
add(s); 
vis[s]=1; 
p=delete(); 
if(p!=0) 
printf(" %d",p); 
while(p!=0) 
{ 
for(i=1;i<=n;i++) 
if((a[p][i]!=0)&&(vis[i]==0)) 
{ 
add(i); 
vis[i]=1; 
} 
p=delete(); 
if(p!=0) 
printf(" %d ",p); 
} 
for(i=1;i<=n;i++) 
if(vis[i]==0) 
bfs(i,n); 
}


void add(int item) 
{ 
if(rear==19) 
printf("QUEUE FULL"); 
else 
{ 
if(rear==-1) 
{ 
q[++rear]=item; 
front++; 
} 
else 
q[++rear]=item; 
} 
} 
int delete() 
{ 
int k; 
if((front>rear)||(front==-1)) 
return(0); 
else 
{ 
k=q[front++]; 
return(k); 
} 
} 


//***************DFS(depth-first search) code******************// 
void dfs(int s,int n) 
{ 
int i,k; 
push(s); 
vis[s]=1; 
k=pop(); 
if(k!=0) 
printf(" %d ",k); 
while(k!=0) 
{ 
for(i=1;i<=n;i++) 
if((a[k][i]!=0)&&(vis[i]==0)) 
{ 
push(i); 
vis[i]=1; 
} 
k=pop(); 
if(k!=0) 
printf(" %d ",k); 
} 
for(i=1;i<=n;i++) 
if(vis[i]==0) 
dfs(i,n); 
} 
void push(int item) 
{ 
if(top==19) 
printf("Stack overflow "); 
else 
stack[++top]=item; 
} 
int pop() 
{ 
int k; 
if(top==-1) 
return(0); 
else 
{ 
k=stack[top--]; 
return(k); 
} 
}

///////////////////////////////////////////////// C++ program to print DFS traversal from
// a given vertex in a  given graph
#include<iostream>
#include<list>
using namespace std;
 
// Graph class represents a directed graph
// using adjacency list representation
class Graph
{
    int V;    // No. of vertices
 
    // Pointer to an array containing
    // adjacency lists
    list<int> *adj;
 
    // A recursive function used by DFS
    void DFSUtil(int v, bool visited[]);
public:
    Graph(int V);   // Constructor
 
    // function to add an edge to graph
    void addEdge(int v, int w);
 
    // DFS traversal of the vertices
    // reachable from v
    void DFS(int v);
};
 
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
}
 
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to vs list.
}
 
void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and
    // print it
    visited[v] = true;
    cout << v << " ";
 
    // Recur for all the vertices adjacent
    // to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
 
// DFS traversal of the vertices reachable from v.
// It uses recursive DFSUtil()
void Graph::DFS(int v)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
 
    // Call the recursive helper function
    // to print DFS traversal
    DFSUtil(v, visited);
}
 
int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
 
    cout << "Following is Depth First Traversal"
            " (starting from vertex 2) \n";
    g.DFS(2);
 
    return 0;
}


///////////////////////////////***********************************************************
* You can use all the programs on  www.c-program-example.com
* for personal and learning purposes. For permissions to use the
* programs for commercial purposes,
* contact info@c-program-example.com
* To find more C programs, do visit www.c-program-example.com
* and browse!
* 
*                      Happy Coding
***********************************************************/

#include<stdio.h>
#include<conio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]={0},min,mincost=0,cost[10][10];
void main()
{
 clrscr();
 printf("n Enter the number of nodes:");
 scanf("%d",&n);
 printf("n Enter the adjacency matrix:n");
 for(i=1;i<=n;i++)
  for(j=1;j<=n;j++)
  {
   scanf("%d",&cost[i][j]);
   if(cost[i][j]==0)
    cost[i][j]=999;
  }
 visited[1]=1;
 printf("n");
 while(ne<n)
 {
  for(i=1,min=999;i<=n;i++)
   for(j=1;j<=n;j++)
    if(cost[i][j]<min)
     if(visited[i]!=0)
     {
      min=cost[i][j];
      a=u=i;
      b=v=j;
     }
  if(visited[u]==0 || visited[v]==0)
  {
   printf("n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
   mincost+=min;
   visited[b]=1;
  }
  cost[a][b]=cost[b][a]=999;
 }
 printf("n Minimun cost=%d",mincost);
 getch();
}



////////////minimum spanning tree using prims algorithm
#include<stdio.h>
#include<stdlib.h>
 
#define infinity 9999
#define MAX 20
 
int G[MAX][MAX],spanning[MAX][MAX],n;
 
int prims();
 
int main()
{
    int i,j,total_cost;
    printf("Enter no. of vertices:");
    scanf("%d",&n);
    
    printf("\nEnter the adjacency matrix:\n");
    
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&G[i][j]);
    
    total_cost=prims();
    printf("\nspanning tree matrix:\n");
    
    for(i=0;i<n;i++)
    {
        printf("\n");
        for(j=0;j<n;j++)
            printf("%d\t",spanning[i][j]);
    }
    
    printf("\n\nTotal cost of spanning tree=%d",total_cost);
    return 0;
}
 
int prims()
{
    int cost[MAX][MAX];
    int u,v,min_distance,distance[MAX],from[MAX];
    int visited[MAX],no_of_edges,i,min_cost,j;
    
    //create cost[][] matrix,spanning[][]
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
        {
            if(G[i][j]==0)
                cost[i][j]=infinity;
            else
                cost[i][j]=G[i][j];
                spanning[i][j]=0;
        }
        
    //initialise visited[],distance[] and from[]
    distance[0]=0;
    visited[0]=1;
    
    for(i=1;i<n;i++)
    {
        distance[i]=cost[0][i];
        from[i]=0;
        visited[i]=0;
    }
    
    min_cost=0;        //cost of spanning tree
    no_of_edges=n-1;        //no. of edges to be added
    
    while(no_of_edges>0)
    {
        //find the vertex at minimum distance from the tree
        min_distance=infinity;
        for(i=1;i<n;i++)
            if(visited[i]==0&&distance[i]<min_distance)
            {
                v=i;
                min_distance=distance[i];
            }
            
        u=from[v];
        
        //insert the edge in spanning tree
        spanning[u][v]=distance[v];
        spanning[v][u]=distance[v];
        no_of_edges--;
        visited[v]=1;
        
        //updated the distance[] array
        for(i=1;i<n;i++)
            if(visited[i]==0&&cost[i][v]<distance[i])
            {
                distance[i]=cost[i][v];
                from[i]=v;
            }
        
        min_cost=min_cost+cost[u][v];
    }
    
    return(min_cost);
}


/////////////////////////////////////// krushals algorithm msp
#define MAX 30
 
typedef struct edge
{
    int u,v,w;
}edge;
 
typedef struct edgelist
{
    edge data[MAX];
    int n;
}edgelist;
 
edgelist elist;
 
int G[MAX][MAX],n;
edgelist spanlist;
 
void kruskal();
int find(int belongs[],int vertexno);
void union1(int belongs[],int c1,int c2);
void sort();
void print();
 
void main()
{
    int i,j,total_cost;
    
    printf("\nEnter number of vertices:");
    
    scanf("%d",&n);
    
    printf("\nEnter the adjacency matrix:\n");
    
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&G[i][j]);
            
    kruskal();
    print();
}
 
void kruskal()
{
    int belongs[MAX],i,j,cno1,cno2;
    elist.n=0;
 
    for(i=1;i<n;i++)
        for(j=0;j<i;j++)
        {
            if(G[i][j]!=0)
            {
                elist.data[elist.n].u=i;
                elist.data[elist.n].v=j;
                elist.data[elist.n].w=G[i][j];
                elist.n++;
            }
        }
 
    sort();
    
    for(i=0;i<n;i++)
        belongs[i]=i;
    
    spanlist.n=0;
    
    for(i=0;i<elist.n;i++)
    {
        cno1=find(belongs,elist.data[i].u);
        cno2=find(belongs,elist.data[i].v);
        
        if(cno1!=cno2)
        {
            spanlist.data[spanlist.n]=elist.data[i];
            spanlist.n=spanlist.n+1;
            union1(belongs,cno1,cno2);
        }
    }
}
 
int find(int belongs[],int vertexno)
{
    return(belongs[vertexno]);
}
 
void union1(int belongs[],int c1,int c2)
{
    int i;
    
    for(i=0;i<n;i++)
        if(belongs[i]==c2)
            belongs[i]=c1;
}
 
void sort()
{
    int i,j;
    edge temp;
    
    for(i=1;i<elist.n;i++)
        for(j=0;j<elist.n-1;j++)
            if(elist.data[j].w>elist.data[j+1].w)
            {
                temp=elist.data[j];
                elist.data[j]=elist.data[j+1];
                elist.data[j+1]=temp;
            }
}
 
void print()
{
    int i,cost=0;
    
    for(i=0;i<spanlist.n;i++)
    {
        printf("\n%d\t%d\t%d",spanlist.data[i].u,spanlist.data[i].v,spanlist.data[i].w);
        cost=cost+spanlist.data[i].w;
    }
 
    printf("\n\nCost of the spanning tree=%d",cost);
}


///////////////////////////////////////warshallls algo
#include<stdio.h>
#define LIMIT 100
 
void show(int mat[LIMIT][LIMIT], int n);
void new_graph();
int adjacency_matrix[LIMIT][LIMIT];
int n;
 
int main()
{
      int P[LIMIT][LIMIT];
      int i, j, k;
      new_graph();
      printf("\nadjacency_matrixacency Matrix\n");
      show(adjacency_matrix, n);
      for(i = 0; i < n; i++)
      {
            for(j = 0; j < n; j++)
            {
                  P[i][j] = adjacency_matrix[i][j];
            }
      }
      for(k = 0; k < n; k++)
      {
            for(i = 0; i < n; i++)
            {
                  for(j = 0; j < n; j++)
                  {
                        P[i][j] = (P[i][j] || (P[i][k] && P[k][j]));
                  }
            }
            printf("P%d is: \n", k);
            show(P, n);
      }
      printf("P%d is the path matrix of the given graph\n", k - 1);
      return 0;
}
 
void show(int mat[LIMIT][LIMIT], int n)
{
      int i, j;
      for(i = 0; i < n; i++)
      {
            for(j = 0; j < n; j++)
            {
                  printf("%3d", mat[i][j]);
            }
            printf("\n");
      }
}
 
void new_graph()
{
      int count, maximum_edges, origin, destination;
      printf("Enter Total Number of Vertices:\t");
      scanf("%d", &n);
      maximum_edges = n * (n - 1);
      for(count = 1; count <= maximum_edges; count++)
      {
            printf("\nCo - Ordinates for Edge No. %d [(-1 -1) To Quit]:\t", count);
            printf("\nEnter Origin Point:\t");
            scanf("%d", &origin);
            printf("\nEnter Destination Point:\t");
            scanf("%d", &destination);
            if((origin == -1) && (destination == -1))
            {
                  break;
            }
            if(destination >= n ||  origin < 0 || origin >= n || destination < 0)
            {
                  printf("Invalid Edge Input:\n");
                  count--;
            }
            else
            {
                  adjacency_matrix[origin][destination] = 1;
            }
      }
}



////////////////////////////////floyd warshalls
// C Program for Floyd Warshall Algorithm
#include<stdio.h>
 
// Number of vertices in the graph
#define V 4
 
/* Define Infinite as a large enough value. This value will be used
  for vertices not connected to each other */
#define INF 99999
 
// A function to print the solution matrix
void printSolution(int dist[][V]);
 
// Solves the all-pairs shortest path problem using Floyd Warshall algorithm
void floydWarshall (int graph[][V])
{
    /* dist[][] will be the output matrix that will finally have the shortest 
      distances between every pair of vertices */
    int dist[V][V], i, j, k;
 
    /* Initialize the solution matrix same as input graph matrix. Or 
       we can say the initial values of shortest distances are based
       on shortest paths considering no intermediate vertex. */
    for (i = 0; i < V; i++)
        for (j = 0; j < V; j++)
            dist[i][j] = graph[i][j];
 
    /* Add all vertices one by one to the set of intermediate vertices.
      ---> Before start of a iteration, we have shortest distances between all
      pairs of vertices such that the shortest distances consider only the
      vertices in set {0, 1, 2, .. k-1} as intermediate vertices.
      ----> After the end of a iteration, vertex no. k is added to the set of
      intermediate vertices and the set becomes {0, 1, 2, .. k} */
    for (k = 0; k < V; k++)
    {
        // Pick all vertices as source one by one
        for (i = 0; i < V; i++)
        {
            // Pick all vertices as destination for the
            // above picked source
            for (j = 0; j < V; j++)
            {
                // If vertex k is on the shortest path from
                // i to j, then update the value of dist[i][j]
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
 
    // Print the shortest distance matrix
    printSolution(dist);
}
 
/* A utility function to print solution */
void printSolution(int dist[][V])
{
    printf ("Following matrix shows the shortest distances"
            " between every pair of vertices \n");
    for (int i = 0; i < V; i++)
    {
        for (int j = 0; j < V; j++)
        {
            if (dist[i][j] == INF)
                printf("%7s", "INF");
            else
                printf ("%7d", dist[i][j]);
        }
        printf("\n");
    }
}
 
// driver program to test above function
int main()
{
    /* Let us create the following weighted graph
            10
       (0)------->(3)
        |         /|\
      5 |          |
        |          | 1
       \|/         |
       (1)------->(2)
            3           */
    int graph[V][V] = { {0,   5,  INF, 10},
                        {INF, 0,   3, INF},
                        {INF, INF, 0,   1},
                        {INF, INF, INF, 0}
                      };
 
    // Print the solution
    floydWarshall(graph);
    return 0;
}



////////////dijkstras algorithm

#include<conio.h>
#define INFINITY 9999
#define MAX 10
 
void dijkstra(int G[MAX][MAX],int n,int startnode);
 
int main()
{
    int G[MAX][MAX],i,j,n,u;
    printf("Enter no. of vertices:");
    scanf("%d",&n);
    printf("\nEnter the adjacency matrix:\n");
    
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            scanf("%d",&G[i][j]);
    
    printf("\nEnter the starting node:");
    scanf("%d",&u);
    dijkstra(G,n,u);
    
    return 0;
}
 
void dijkstra(int G[MAX][MAX],int n,int startnode)
{
 
    int cost[MAX][MAX],distance[MAX],pred[MAX];
    int visited[MAX],count,mindistance,nextnode,i,j;
    
    //pred[] stores the predecessor of each node
    //count gives the number of nodes seen so far
    //create the cost matrix
    for(i=0;i<n;i++)
        for(j=0;j<n;j++)
            if(G[i][j]==0)
                cost[i][j]=INFINITY;
            else
                cost[i][j]=G[i][j];
    
    //initialize pred[],distance[] and visited[]
    for(i=0;i<n;i++)
    {
        distance[i]=cost[startnode][i];
        pred[i]=startnode;
        visited[i]=0;
    }
    
    distance[startnode]=0;
    visited[startnode]=1;
    count=1;
    
    while(count<n-1)
    {
        mindistance=INFINITY;
        
        //nextnode gives the node at minimum distance
        for(i=0;i<n;i++)
            if(distance[i]<mindistance&&!visited[i])
            {
                mindistance=distance[i];
                nextnode=i;
            }
            
            //check if a better path exists through nextnode            
            visited[nextnode]=1;
            for(i=0;i<n;i++)
                if(!visited[i])
                    if(mindistance+cost[nextnode][i]<distance[i])
                    {
                        distance[i]=mindistance+cost[nextnode][i];
                        pred[i]=nextnode;
                    }
        count++;
    }
 
    //print the path and distance of each node
    for(i=0;i<n;i++)
        if(i!=startnode)
        {
            printf("\nDistance of node%d=%d",i,distance[i]);
            printf("\nPath=%d",i);
            
            j=i;
            do
            {
                j=pred[j];
                printf("<-%d",j);
            }while(j!=startnode);
    }
}


///////////////////////////////dijkstras algorithm

// A C++ program for Dijkstra's single source shortest path algorithm.
// The program is for adjacency matrix representation of the graph
  
#include <stdio.h>
#include <limits.h>
  
// Number of vertices in the graph
#define V 9
  
// A utility function to find the vertex with minimum distance value, from
// the set of vertices not yet included in shortest path tree
int minDistance(int dist[], bool sptSet[])
{
   // Initialize min value
   int min = INT_MAX, min_index;
  
   for (int v = 0; v < V; v++)
     if (sptSet[v] == false && dist[v] <= min)
         min = dist[v], min_index = v;
  
   return min_index;
}
  
// A utility function to print the constructed distance array
int printSolution(int dist[], int n)
{
   printf("Vertex   Distance from Source\n");
   for (int i = 0; i < V; i++)
      printf("%d tt %d\n", i, dist[i]);
}
  
// Funtion that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
     int dist[V];     // The output array.  dist[i] will hold the shortest
                      // distance from src to i
  
     bool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest
                     // path tree or shortest distance from src to i is finalized
  
     // Initialize all distances as INFINITE and stpSet[] as false
     for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
  
     // Distance of source vertex from itself is always 0
     dist[src] = 0;
  
     // Find shortest path for all vertices
     for (int count = 0; count < V-1; count++)
     {
       // Pick the minimum distance vertex from the set of vertices not
       // yet processed. u is always equal to src in first iteration.
       int u = minDistance(dist, sptSet);
  
       // Mark the picked vertex as processed
       sptSet[u] = true;
  
       // Update dist value of the adjacent vertices of the picked vertex.
       for (int v = 0; v < V; v++)
  
         // Update dist[v] only if is not in sptSet, there is an edge from 
         // u to v, and total weight of path from src to  v through u is 
         // smaller than current value of dist[v]
         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                                       && dist[u]+graph[u][v] < dist[v])
            dist[v] = dist[u] + graph[u][v];
     }
  
     // print the constructed distance array
     printSolution(dist, V);
}
  
// driver program to test above function
int main()
{
   /* Let us create the example graph discussed above */
   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                      {4, 0, 8, 0, 0, 0, 0, 11, 0},
                      {0, 8, 0, 7, 0, 4, 0, 0, 2},
                      {0, 0, 7, 0, 9, 14, 0, 0, 0},
                      {0, 0, 0, 9, 0, 10, 0, 0, 0},
                      {0, 0, 4, 14, 10, 0, 2, 0, 0},
                      {0, 0, 0, 0, 0, 2, 0, 1, 6},
                      {8, 11, 0, 0, 0, 0, 1, 0, 7},
                      {0, 0, 2, 0, 0, 0, 6, 7, 0}
                     };
  
    dijkstra(graph, 0);
  
    return 0;
}




/////////////////////////////////////////C program for tree traversal...............
#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
struct node
{
struct node *lchild;
int info;
struct node *rchild;
};
struct node *insert(struct node *ptr, int ikey);
void preorder(struct node *ptr);
void inorder(struct node *ptr);
void postorder(struct node *ptr);
int main( )
{
struct node *root=NULL,*ptr;
int choice,k;
while(1)
{
printf("\n");
printf("Enter your choice : \n");
printf("1.Insert\n");
printf("2.Preorder Traversal\n");
printf("3.Inorder Traversal\n");
printf("4.Postorder Traversal\n");
scanf("%d",&choice);
switch(choice)
{
case 1:
printf("Enter the key to be inserted : ");
scanf("%d",&k);
root = insert(root, k);
break;
case 2:
preorder(root);
break;
case 3:
inorder(root);
break;
case 4:
postorder(root);
break;
default:
printf("wrong selection");
}
}
}
struct node *insert(struct node *ptr, int ikey )
{
if(ptr==NULL)
{
ptr = (struct node *) malloc(sizeof(struct node));
ptr->info = ikey;
ptr->lchild = NULL;
ptr->rchild = NULL;
}
else if(ikey < ptr->info) /*Insertion in left subtree*/
ptr->lchild = insert(ptr->lchild, ikey);
else if(ikey > ptr->info) /*Insertion in right subtree */
ptr->rchild = insert(ptr->rchild, ikey);
else
printf("Duplicate key\n");
return ptr;
}
void preorder(struct node *ptr)
{
if(ptr == NULL ) /*Base Case*/
return;
printf("%d ",ptr->info);
preorder(ptr->lchild);
preorder(ptr->rchild);
}/*End of preorder( )*/
void inorder(struct node *ptr)
{
if(ptr == NULL )/*Base Case*/
return;
inorder(ptr->lchild);
printf("%d ",ptr->info);
inorder(ptr->rchild);
}/*End of inorder( )*/
void postorder(struct node *ptr)
{
if(ptr == NULL )/*Base Case*/
return;
postorder(ptr->lchild);
postorder(ptr->rchild);
printf("%d ",ptr->info);
getch();
}/*End of postorder( )*/



// C/C++ program to solve fractional Knapsack Problem
#include <bits/stdc++.h>
using namespace std;
 
// Stucture for Item which store weight and corresponding
// value of Item
struct Item
{
    int value, weight;
 
    // Constructor
    Item(int value, int weight) : value(value), weight(weight)
    {}
};
 
// Comparison function to sort Item according to val/weight ratio
bool cmp(struct Item a, struct Item b)
{
    double r1 = (double)a.value / a.weight;
    double r2 = (double)b.value / b.weight;
    return r1 > r2;
}
 
// Main greedy function to solve problem
double fractionalKnapsack(int W, struct Item arr[], int n)
{
    //    sorting Item on basis of ration
    sort(arr, arr + n, cmp);
 
    //    Uncomment to see new order of Items with their ratio
    /*
    for (int i = 0; i < n; i++)
    {
        cout << arr[i].value << "  " << arr[i].weight << " : "
             << ((double)arr[i].value / arr[i].weight) << endl;
    }
    */
 
    int curWeight = 0;  // Current weight in knapsack
    double finalvalue = 0.0; // Result (value in Knapsack)
 
    // Looping through all Items
    for (int i = 0; i < n; i++)
    {
        // If adding Item won't overflow, add it completely
        if (curWeight + arr[i].weight <= W)
        {
            curWeight += arr[i].weight;
            finalvalue += arr[i].value;
        }
 
        // If we can't add current Item, add fractional part of it
        else
        {
            int remain = W - curWeight;
            finalvalue += arr[i].value * ((double) remain / arr[i].weight);
            break;
        }
    }
 
    // Returning final value
    return finalvalue;
}
 
// driver program to test above function
int main()
{
    int W = 50;   //    Weight of knapsack
    Item arr[] = {{60, 10}, {100, 20}, {120, 30}};
 
    int n = sizeof(arr) / sizeof(arr[0]);
 
    cout << "Maximum value we can obtain = "
         << fractionalKnapsack(W, arr, n);
    return 0;
}



#include <iostream>
 
using namespace std;
 
// A utility function that returns maximum of two integers
int max(int a, int b)
{
    return (a > b) ? a : b;
}
 
// Returns the maximum value that can be put in a knapsack of capacity W
int knapSack(int W, int wt[], int val[], int n)
{
    int i, w;
    int K[n + 1][W + 1];
 
    // Build table K[][] in bottom up manner
    for (i = 0; i <= n; i++)
    {
        for (w = 0; w <= W; w++)
        {
            if (i == 0 || w == 0)
                K[i][w] = 0;
            else if (wt[i - 1] <= w)
                K[i][w]
                        = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
            else
                K[i][w] = K[i - 1][w];
        }
    }
 
    return K[n][W];
}
 
int main()
{
    cout << "Enter the number of items in a Knapsack:";
    int n, W;
    cin >> n;
    int val[n], wt[n];
    for (int i = 0; i < n; i++)
    {
        cout << "Enter value and weight for item " << i << ":";
        cin >> val[i];
        cin >> wt[i];
    }
 
    //    int val[] = { 60, 100, 120 };
    //    int wt[] = { 10, 20, 30 };
    //    int W = 50;
    cout << "Enter the capacity of knapsack";
    cin >> W;
    cout << knapSack(W, wt, val, n);
 
    return 0;
}














